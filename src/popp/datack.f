      SUBROUTINE DATACK(ZP,CP,NWL,H,HBOT,CBOT,RHO,ALPBT,
     2NBL,ZS,ZR,NS,NR,NSR,NL,FREQ,NMODES,IERR)
      INTEGER I,IEF,IERR,ITMAX,J,K,L,NBL,NL,NMODES,NMIN,
     1    NR,NS,NSR,NWL
      REAL    ALPBT,CBOT,CP,FREQ,H,HBOT,RHO,TOLU,VMAX,
     1    VMIN,ZP,ZR,ZS,TOLK,TOLGAM
      DIMENSION ZP(NWL),CP(NWL),HBOT(NBL),CBOT(NBL),RHO(0:NBL),
     2ALPBT(NBL),ZS(NS),ZR(NR)
      COMMON/PAR/VMIN,VMAX,NMIN,ITMAX,IEF
      COMMON/TOL/TOLK,TOLU,TOLGAM
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -CHECKS ALL INPUT DATA FOR CONTRADICTIONS AND MISTAKES
C
C       INPUT VARIABLES:
C         (ALL INPUT TO NMODES)
C
C       OUTPUT VARIABLES:
C         IERR
C
C       NOTES:
C         EACH TYPE OF ERROR HAS A CODE NUMBER RECOGNIZED BY SUBROUTINE
C        ERROR . AN APROPRIATE ERROR MESSAGE IS OUTPUTED BY SUBROUTINE
C        ERROR
C         RETURNS THE RELEVENT ERROR CODE TO NMODES
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C       GO THROUGH ALL INPUT DATA , CALL ERROR IF AN ERROR MESSAGE OR
C        A WARNING MESSAGE IS NEEDED
C       DO NOT RETURN TO NMODES UNTIL ALL PARAMETERS HAVE BEEN CHECKED
C
      IF(NWL.LT.1)CALL ERROR(30,IERR,FLOAT(NWL),0.0,0.0)
      IF(NWL.EQ.1)GO TO 150
      IF(NWL.LT.1)GO TO 175
      DO 100 I=1,NWL-1
      IF(CP(I).LT.0.0)CALL ERROR(3,IERR,FLOAT(I),CP(I),ZP(I))
      IF(ZP(I).LT.0.0)CALL ERROR(4,IERR,FLOAT(I),CP(I),ZP(I))
      IF(ZP(I).GE.ZP(I+1))CALL ERROR(5,IERR,FLOAT(I),ZP(I),ZP(I+1))
  100 CONTINUE
  150         IF(H.LT.ZP(NWL))CALL ERROR(6,IERR,ZP(NWL),H,0.0)
      IF(CP(NWL).LE.0.0)CALL ERROR(3,IERR,FLOAT(NWL),CP(NWL),ZP(NWL))
      IF(ZP(NWL).LE.0.0)CALL ERROR(4,IERR,FLOAT(NWL),CP(NWL),ZP(NWL))
  175 IF(RHO(0).LE.0.0)CALL ERROR(31,IERR,RHO(0),0.0,0.0)
      IF(FREQ.LE.0.0)CALL ERROR(7,IERR,FREQ,0.0,0.0)
      IF(NBL.LT.1)CALL ERROR(32,IERR,FLOAT(NBL),0.0,0.0)
      IF(NBL.LT.1)GO TO 250
      DO 200 J=1,NBL
      IF(HBOT(J).LE.0.0.AND.J.NE.NBL)CALL ERROR(8,IERR,FLOAT(J),
     2HBOT(J),0.0)
      IF(CBOT(J).LE.0.0)CALL ERROR(9,IERR,FLOAT(J),CBOT(J),0.0)
      IF(RHO(J).LE.0.0)CALL ERROR(10,IERR,FLOAT(J),RHO(J),0.0)
      IF(ALPBT(J).LT.0.0)CALL ERROR(33,IERR,FLOAT(J),ALPBT(J),0.0)
  200 CONTINUE
  250 IF(NS.EQ.0.AND.NR.EQ.0)CALL ERROR(38,IERR,0.0,0.0,0.0)
      IF(NS.EQ.0.AND.NR.EQ.0)GO TO 450
      IF(NS.LT.0)CALL ERROR(34,IERR,FLOAT(NS),0.0,0.0)
      IF(NS.LE.0)GO TO 350
      DO 300 K=1,NS
      IF(ZS(K).LE.0.0)CALL ERROR(11,IERR,FLOAT(K),ZS(K),0.0)
      IF(ZS(K).GT.H)CALL ERROR(15,IERR,FLOAT(K),ZS(K),0.0)
  300 CONTINUE
  350 IF(NR.LT.0)CALL ERROR(35,IERR,FLOAT(NR),0.0,0.0)
      IF(NR.LE.0)GO TO 450
      DO 400 L=1,NR
      IF(ZR(L).LE.0.0)CALL ERROR(12,IERR,FLOAT(L),ZR(L),0.0)
      IF(ZR(L).GT.H)CALL ERROR(14,IERR,FLOAT(L),ZR(L),0.0)
  400 CONTINUE
  450 IF(VMIN.LT.0.0)CALL ERROR(16,IERR,VMIN,0.0,0.0)
      IF(VMAX.LT.0.0)CALL ERROR(17,IERR,VMAX,0.0,0.0)
      IF(VMAX.LE.VMIN)CALL ERROR(18,IERR,VMAX,VMIN,0.0)
      IF(NMIN.LE.0)CALL ERROR(19,IERR,FLOAT(NMIN),0.0,0.0)
      IF(TOLK.LE.0.0)CALL ERROR(20,IERR,TOLK,0.0,0.0)
      IF(ITMAX.LE.0)CALL ERROR(21,IERR,FLOAT(ITMAX),0.0,0.0)
      IF(TOLU.LE.0.0)CALL ERROR(39,IERR,TOLU,0.0,0.0)
      IF(TOLGAM.LE.0.0)CALL ERROR(40,IERR,TOLGAM,0.0,0.0)
      IF(IEF.LT.0.OR.IEF.GT.99)CALL ERROR(41,IERR,FLOAT(IEF),0.0,0.0)
      IF(NMODES.LE.0)CALL ERROR(13,IERR,FLOAT(NMODES),0.0,0.0)
      IF(NL.LE.NBL)CALL ERROR(36,IERR,FLOAT(NL),FLOAT(NBL),0.0)
      IF(NSR.NE.NS+NR)CALL ERROR(37,IERR,FLOAT(NSR),0.0,0.0)
      RETURN
      END
