      FUNCTION ATTDEP (Z, F)

C Attenuation in water as a function of depth and frequency - 
C   Thorpe version

C AUTHOR:	Dale D Ellis
C DATE WRITTEN: 29-Jan-91
C LAST EDIT:    20-Oct-94

C MODIFICATIONS:
C  August-94: Modifications to attenuation handling, including 
C	        the addition of a depth dependence. J Theriault.

C REMARKS:
C  This is to return the version in VMODES that was changed by 
C    Terry Deveau. Note: dB/nepers is now required. 

C  Z - depth in meters
C  F - frequency in Hz
C  ATTDEP - loss in Nepers/m

C  THORP - dB/kiloyard
C  CONV - Conversion dB/kyd to nepers/m
C  CONV1 - Conversion dB/km to nepers/m
C  URICK - See p.108 of Urick's book (3rd ed.) 
C  ALPWC - attenuation in dB/(km-Hz) as a function of equally spaced 
C	   depth points.

      implicit none
      REAL CONV, RLN10,conv1
      PARAMETER (RLN10 = 2.3025851, CONV = 0.001/0.9144 * RLN10/20.) 
      PARAMETER ( CONV1 = 0.001 * RLN10/20.)
      REAL	ATTDEP, Z, F
      REAL	FKSQ, THORP, URICK,tabinp
      real   attflg,depthinc,alpwc(100)
      common /vol_atten/attflg,depthinc,alpwc
      integer iz

      if (attflg.eq.-1.) then
         FKSQ = (F/1000.)**2
         THORP = 0.1*FKSQ/(1.+FKSQ) + 40.*FKSQ/(4100.+FKSQ) 
         ATTDEP = CONV * THORP
      elseif (attflg.eq.-2.) then
         FKSQ = (F/1000.)**2
         THORP = 0.1*FKSQ/(1.+FKSQ) + 40.*FKSQ/(4100.+FKSQ) 
         URICK = THORP + 0.003 + 2.75E-4*FKSQ
         ATTDEP = CONV * URICK
      elseif (attflg.eq.1) then
         attdep =conv1*alpwc(1)*f
      else
         iz = int(z/depthinc)+1
         if (iz.ge.200) then
            iz = 199
            print*, 'WARNING: from ATTDEP'
            print*, 'Depth below those specified for attenuations' 
         endif
         tabinp = (alpwc(iz)-alpwc(iz+1))/depthinc* 
     *             (z-depthinc*(iz+1)) + alpwc(iz+1)
         attdep =conv1*tabinp*f
      endif
C
      RETURN
      END
C
C   ********************************************************************
C   *                                                                  *
C   *  Copyright (c) Department of National Defence of Canada 1988     *
C   *                                                                  *
C   *  The computer software described herein is the sole property     *
C   *  of the Department of National Defence, Canada.                  *
C   *                                                                  *
C   *  Its use or distribution, in whole or in part, is not permitted  *
C   *  without written authorization by the Department.                *
C   *                                                                  *
C   *  Requests should be forwarded to:                                *
C   *           Chief                                                  *
C   *           Defence Research Establishment Atlantic                *
C   *           P.O. Box 1012                                          *
C   *           Dartmouth, Nova Scotia, Canada                         *
C   *           B2Y 3Z7                                                *
C   *                                                                  *
C   *  The Department assumes no express or implied liability          *
C   *  resulting from use of this software.                            *
C   *                                                                  *
C   ********************************************************************
C
C  SUBPROGRAM: MODES
C  PURPOSE:    NORMAL MODE WAVE NUMBERS AND MODE FUNCTIONS FOR AN
C              ARBITRARY SOUND SPEED AND DENSITY PROFILE
C  LANGUAGE:   FORTRAN
C  AUTHORS:    BRIAN LEVERMAN AND DALE D ELLIS  -- SUMMER 1978
 
C MODIFICATIONS:
C   1978-1982:  Various modifications by Dale Ellis
C   Jun-Aug-82: Fortran V.6 updates, and some bug fixes.
C               AESD test cases.  By Mark Radcliffe.
C   19-Jul-84: Depth-dependent attenuation for Ian Fraser (FMODES)
C   18-Dec-84: Bug corrections, attenuation common, and group velocities
C         -86: VAX conversion ?
C    5-Apr-88: FMODES + ATTENU(FMODES.FOR) + OUTPUT(NEWMOD.FOR)
C    6-Apr-88: Fix METHOD=1/METHOD=2 oscillation in MODES
C   31-Oct-88: PLTSUB shortened format statements
C    2-Nov-88: DATACK changed errors on output unit
C    1-Jun-89: Date of record for changes relating to CANARPS and REVERB,
C              Terry J. Deveau
C    5-Oct-89: Made to conform to ANSI standard FORTRAN.  Terry J. Deveau
C LAST EDIT: 5-Oct-89
C
 
C REFERENCES:
C   Brian Leverman and Dale D. Ellis, "Software documation for normal
C     modes subprogram: MODES", DREA Research Note, AM/82/4, June 1982.
C   Brian Leverman, "Users guide to normal mode propagation loss
C     package PROLOS", DREA Research Note, AM/82/3, June 1982.
C   Dale D. Ellis, "A two-ended shooting technique for calculating
C     normal modes in underwater acoustic propagation", D.R.E.A.
C     Report 85/105, September 1985.
C   Terry J. Deveau, "Enhancements to the PROLOS Normal-mode
C     Acoustic Propagation Model", DREA Contractor Report CR/89/?,
C     June 1989
 
C CONTENTS:
C     MODES     ERROR    INTIN    LINEAR
C     ATTENU    QTRIAL   XMATCH   LAYER
C     ATTDEP    TURNPT   NORMAL   PLTSUB
C     DATACK    INTPTS   ITPDAT   KIRKFF
C     DOPAR     INTOUT   OUTPUT   KIRKFB
 
      SUBROUTINE OMODES (NWL,ZP,CP,BH,H,NBL,HBOT,CBOT,ALPBT,RHO,
     1    ROUGH,NS,NR,ZS,ZR,NL,ZI,CI,FREQ,MAXNM,NMODES,LOWER,NMCAL,
     2    WORK,KND,KNI,UN,MAXNL,AMPL,PHSE,PRTKNI,PRTKNB,
     3    PRTWAT,PRTSED,PRTSUB,PRTGVL,IERR)
 
      INTEGER I,ICNT1,ICNT2,IEF,IERR,INDEX,ISR(25),ITMAX,MAXNL,IUPPER,J,
     1    K,LOWER,METHOD,NBL,NL,NMCAL,NMIN,NPT,NR,NS,NSR,NWATL,NWL,
     2    NZC,NZCPV,NZCQ1,NMODES,Z1,Z2,ZA,ZB,ZAQ1,ZBQ1,ZM,HOLZA, HOLZB,
     3    HOLNZC,MAXNM
      REAL KNI(NMODES),TOLGAM,TOLK,BH,RHO(0:NBL),ALPBT(NBL),ATNBOT,
     1    ATNSED,ATNSHR,ATNSUB,ATNSUR,ATNWAT,CBOT(NBL),CP(NWL),
     2    DELKNB,DELKNI,DELOUT,FREQ,GRPVEL,H,HBOT(NBL),RHO1,RK0SQ,RK1SQ,
     3    RKN,UN(MAXNM,*),UNPZ,UNPZH,UNZH,VMAX,VMIN,ZMX,ZP(NWL),ZR(NR),
     4    ZS(NS),AMPL(MAXNL,NMODES),PHSE(MAXNL,NMODES),ROUGH(0:NBL),
     5    PRTKNI(NMODES),PRTKNB(NMODES),PRTWAT(NMODES),PRTSED(NMODES),
     6    PRTSUB(NMODES),PRTGVL(NMODES),TOLU,SIG0,SIG1
      DOUBLE PRECISION WORK(NL,2),SMOUT,SMIN,UOUT,UDROUT,UIN,UDRIN,
     1    Q,Q1,Q2,DELQ,DELQPV,ZI(NL),CI(NL),CMIN,CMAX,OMEGA,KND(NMODES),
     2    FACTOR,HH,SUMA,SUMB,SR(25)
 
      COMMON /PAR/    VMIN,VMAX,NMIN,ITMAX,IEF
      COMMON /TOL/    TOLK,TOLU,TOLGAM
 
      COMMON /DATA/   OMEGA,CMIN,CMAX
      COMMON /ATTENS/ ATNWAT,ATNSED,ATNSUB,ATNSUR,ATNBOT,ATNSHR,GRPVEL
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       NORMAL MODE SUBROUTINE
C
C               WRITTEN BY: BRIAN LEVERMAN
C               DEFENCE RESEARCH ESTABLISHMENT ATLANTIC
C                 DARTMOUTH,NOVA SCOTIA,CANADA
C               UNDER THE SUPERVISION AND ASSISTANCE OF:
C                       DR. DALE D. ELLIS
C                       DURING: MAY TO AUGUST , 1978
C               WRITTEN ON:  DEC-20/40,OPERATING SYSTEM: TOPS-20
C                       LANGUAGE: FORTRAN IV
C                       PRECISION: INPUT/OUTPUT-SINGLE
C                                : INTERNALLY-SINGLE/DOUBLE
C
C
C       FUNCTION:
C          THE SUBROUTINE MODES CALCULATES THE EIGENVALUES AND
C       EIGENFUNCTIONS WHICH ARE THE DISCRETE SOLUTIONS OF THE
C       ACOUSTIC WAVE EQUATION IN THE CONTEXT OF UNDERWATER ACOUSTICS
C       AS WELL AS THE ATTENUATION OF THESE EIGENFUNCTIONS.
C       THE SUBROUTINE USES AN ARBITARY VELOCITY PROFILE IN THE
C       WATER COLUMN AND A LAYERED BOTTOM.
C
C       SUBROUTINES CALLED BY NMODES:
C
C       DATACK,ITPDAT,DOPAR,QTRIAL,TURNPT,INTPTS,INTOUT,INTIN,NORMAL,
C       OUTPUT,ATTENU,ERROR, KIRKFF,KIRKFB
C
C       FUNCTIONS CALLED BY NMODES:
C
C       XMATCH
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C       NOTES FOR THIS SUBROUTINE:
C         TWO METHODS ARE USED TO CONVERGE TO AN ACCEPTABLE EIGENVALUE
C        FIRST A HALVING METHOD UNTIL THE VALUE OF Q IS REASONABLY
C        CLOSE AND THEN A SECOND ORDER METHOD TO COMPLETE THE
C        ITERATION TO THE PROPER EIGENVALUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C IMPORTANT VARIABLES:
C
C       PARAMETERS USED IN INPUT/OUTPUT OPERATIONS:
C
C
C       INPUT(ARGUMENT LIST): (ALL SINGLE PRECISION)
C
C       NWL: THE INPUT NUMBER OF POINTS IN THE INPUT VELOCITY PROFILE
C       ZP(NWL): THE DEPTHS IN THE VELOCITY PROFILE (DEPTH=0 AT THE
C          WATER SURFACE,AND IS POSITIVE AT GREATER DEPTHS)
C       CP(NWL): THE SOUND SPEED AT EACH OF THE ABOVE DEPTHS
C       H: THE DEPTH OF THE WATER COLUMN
C       NBL: THE NUMBER OF BOTTOM LAYERS SPECIFIED
C       HBOT(NBL): THE HEIGHT OF EACH BOTTOM LAYER
C       CBOT(NBL): THE SPEED OF SOUND IN EACH BOTTOM LAYER
C       ALPBT(NBL): THE ATTENUATION IN EACH BOTTOM LAYER
C       RHO(0:NBL): CONTAINS ALL THE DENSITY INFORMATION.
C          RHO(0) is the density in the water column and the remaining
C          NBL values are density in each sediment layer
C       NS: THE NUMBER OF SOURCES OF SOUND
C       ZS(NS): THE DEPTH OF EACH OF THESE SOURCES
C       NR: THE NUMBER OF RECEIVERS SPECIFIED
C       ZR(NR): THE DEPTHS OF THESE RECEIVERS
C       FREQ: THE FREQUENCY OF THE SOURCE OF SOUND
C       NMODES: THE MAXIMUM NUMBER OF MODES TO BE CALCULATED
C       MAXNM: THE FIRST DIMENSION OF ARRAY UN IN THE CALLING ROUTINE
C       NL: THE SUM OF NBL AND THE NUMBER OF LAYERS YOU WISH TO
C          USE IN THE WATER COLUMN WHEN THE INPUT VELOCITY PROFILE
C          IS INTERPOLATED
C       NSR: NS+NR
C
C       VMIN: A PHASE VELOCITY , ANY EIGENFUNCTION CORRESPONDING TO A
C          PHASE VELOCITY BELOW VMIN WILL NOT BE CALCULATED,
C          DEFAULT VALUE=CMIN
C       VMAX: A PHASE VELOCITY , ANY EIGENFUNCTION CORRESPONDING TO A
C          PHASE VELOCITY GREATER THAN VMAX WILL NOT BE CALCULATED,
C          DEFAULT VALUE=CMAX
C       NMIN: THE FIRST EIGENFUNCTION TO BE CALCULATED, DEFAULT
C          VALUE=1
C       ITMAX: THE MAXIMUM NUMBER OF ITERATIONS ALLOWED IN THE
C          CALCULATION OF EACH EIGENFUNCTION IN EITHER PART OF THE
C          TWO PART PROCEDURE, DEFAULT VALUE=30
C       IEF: THE DEVICE NUMBER TO WHICH ALL ERROR OR WARNING MESSAGES
C          AS WELL AS OPTIONAL PRINTING OUTPUTS WILL BE DIRECTED
C       TOLK: THE TOLERANCE ON THE EIGENVALUE , DEFAULT VALUE=1.0E-8
C       TOLU: THE MINIMUM ALLOWABLE SIZE OF THE EIGENVALUE AT THE
C          MATCHING RADIUS , DEFAULT VALUE=1.0E-4
C       TOLGAM: THE MINIMUM ALLOWABLE SIZE OF GAMMA BEFORE A LINEAR
C          SOLUTION IS USED IN THE LAYER , DEFAULT VALUE=1.0E-4
C
C       OUTPUT: (ALL SINGLE PRECISION)
C
C       LOWER: THE NUMBER OF ZERO CROSSINGS FOR THE FIRST MODE
C          ACTUALLY CALCULATED
C       NMCAL: THE NUMBER OF MODES ACTUALLY CALCULATED
C       KND(NMODES): THE EIGENVALUES CALCULATED (DOUBLE PRECISION VARIABLE)
C       KNI(NMODES): THE ATTENUATIONS OF THE EIGENFUNCTIONS (REAL VARIABLE)
C       UN(MAXNM,NSR): THE EIGENFUNCTIONS EVALUATED AT ALL SOURCE AND
C       RECEIVER DEPTHS
C       IERR: THE ERROR FLAG 0=>NO ERRORS OR WARNINGS HAVE BEEN ISSUED
C          1=>FATAL ERROR HAS OCCOURED EXECUTION HALTED,ALSO
C          WARNINGS MAY HAVE BEEN ISSUED BEFORE THE FATAL ERROR
C          2=>NO FATAL ERRORS BUT AT LEAST 1 WARNING HAS BEEN ISSUED
C
C       VARIABLES IN ARGUMENT LIST USED INTERNALLY: (ALL DOUBLE
C                                                   PRECISION)
C
C       ZI(NL): CONTAINS THE DEPTH, NORMALIZED SO THAT H=1, WHERE
C          EACH OF THE NL LAYERS BEGINS FOR THE INTERPOLATED PROFILE
C       CI(NL): CONTAINS THE AVERAGE OF THE TOP AND BOTTOM VELOCITIES
C          IN EACH OF THE ABOVE LAYERS , TRANSFORMED TO
C          H**2*OMEGA**2/SPEED**2. THE LAST NBL ENTRIES CONTAIN
C          INFORMATION FROM THE BOTTOM LAYERS, THE FIRST NL-NBL
C          LAYERS CONTAIN INFORMATION FROM THE INPUT VELOCITY
C          PROFILE INTERPOLATED LINEARLY
C       WORK(NL,2): THE MATRIX IS USED TO CONTAIN THE EIGENFUNCTION
C          (IN WORK(*,1))AND ITS DERIVATIVE (IN WORK(*,2))AS IT
C          IS BEING CALCULATED. THE VALUE STORED IN POSITION I IS
C          THE VALUE OF THE EIGENFUNCTION AND ITS DERIVATIVE JUST
C          BELOW THE UPPER BOUNDRY OF LAYER I.
C
C
C       PARAMETERS USED INTERNALLY AND NOT APPEARING IN INPUT/OUTPUT
C          OPERATIONS: (ALL REAL VARIABLES ARE DOUBLE PRECISION
C                       EXCEPT ZMX,DELIN,DELOUT)
C
C       NZCQ1: THE NUMBER OF ZERO CROSSINGS IF THE TRIAL EIGENVALUE
C          WERE EQUAL TO Q1 WHICH IS THE LOWER BOUND ON THE EIGENVALUE
C       ZAQ1: THE POINT AT WHICH THE OUTWARDS INTEGRATION BEGINS IF THE
C          TRIAL EIGENVALUE  WERE EQUAL TO Q1, USE THIS VALUE WHEN USING
C          THE SECOND ORDER METHOD (INTEGER)
C       ZBQ1: THE POINT AT WHICH THE INWARDS INTEGRATION BEGINS IF THE
C          TRIAL EIGENVALUE WERE EQUAL TO Q1, USE THIS VALUE WHEN USING
C          THE SECOND ORDER METHOD (INTEGER)
C       ICNT1: ITERATION COUNTER FOR THE HALVING METHOD
C       ICNT2: ITERATION COUNTER FOR THE SECOND ORDER METHOD
C       OMEGA: 2*PI*FREQUENCY
C       CMIN: (H*OMEGA/MINIMUM SOUND SPEED)**2
C       CMAX: (H*OMEGA/SPEED IN LOWEST BOTTOM LAYER)**2
C       NPT: THE NUMBER OF LAYERS IN THE WATER COLUMN USED IN THE
C          INTERPOLATION, NPT=NL-NBL
C       Q: A TRIAL EIGENVALUE
C       Q1: A LOWER BOUND ON AN EIGENVALUE
C       Q2: AN UPPER BOUND ON AN EIGENVALUE
C       NZC: THE NUMBER OF ZERO CROSSINGS OF A TRIAL EIGENFUNCTION
C       DELQ: THE CHANGE IN A TRIAL EIGENVALUE Q TO BE USED TO
C          DETERMINE THE NEXT VALUE FOR Q TO BE TESTED WHEN THE NUMBER
C          OF ZERO CROSSINGS IS CORRECT
C       Z1: THE LAYER WHERE THE UPPER TURNING POINT IS LOCATED (INTEGER)
C       Z2: THE LAYER WHERE THE LOWER TURNING POINT IS LOCATED (INTEGER)
C       SUM=THE MAXIMUM VALUE ALLOWED IN THE SUM TO DETERMINE THE
C          POINTS AT WHICH THE INTEGRATIONS START
C       SUMA: THE SUM WHICH DETERMINES THE POINT AT WHICH THE OUTWARDS
C          INTEGRATION STARTS
C       SUMB: THE SUM WHICH DETERMINES THE POINT AT WHICH THE INWARDS
C          INTEGRATION STARTS
C       ZA: THE LAYER IN WHICH THE OUTWARDS INTEGRATION STARTS (INTEGER)
C       ZB: THE LAYER IN WHICH THE INWARDS INTEGRATION STARTS (INTEGER)
C       ZM: LAYER IN WHICH MATCHING RADIUS IS CONTAINED (INTEGER)
C          THIS IS THE LAYER CONTAINING THE MINIMUM SOUND SPEED
C       SMOUT: THE INTEGRAL, OF THE EIGENFUNCTION SQUARED
C          DIVIDED BY DENSITY, FROM THE SURFACE TO THE MATCHING
C          RADIUS
C       SMIN: THE INTEGRAL, OF THE EIGENVALUE SQUARED DIVIDED BY
C          DENSITY , FROM THE MATCHING RADIUS TO POSITIVE INFINITY
C       GAMMA2: CI(I)-Q
C       GAMMA: SQUARE ROOT(ABSOLUTE VALUE(GAMMA2))
C       ICHS: CHANGE OF SIGN OF THE EIGENFUNCTION IN A LAYER
C          1=>CHANGE OF SIGN, 0=>NO CHANGE OF SIGN
C       IZX: INTEGER PART OF, GAMMA * LAYER HEIGHT / PI
C       ZMX: ACTUAL LOCATION OF MATCHING RADIUS IN LAYER ZM
C          STORED AS A VALUE BETWEEN ZERO AND THE DEPTH OF THE LAYER
C       DELIN: THE ARCTAN OF, THE EIGENFUNCTION DIVIDED BY ITS
C          DERIVATIVE DIVIDED BY THE DENSITY IN THE LAYER,
C          USING THE VALUES FROM THE LAST LAYER IN THE INWARDS
C          INTEGRATION
C       DELOUT: SAME AS ABOVE EXCEPT FROM THE OUTWARDS
C          INTEGRATION
C       UIN: THE VALUE OF THE EIGENFUNCTION AT THE MATCHING RADIUS
C          FROM THE INWARDS INTEGRATION
C       UDRIN: THE VALUE OF THE DERIVATIVE OF THE EIGENFUNCTION
C          AT THE MATCHING RADIUS FROM THE INWARDS INTEGRATION
C       UOUT: THE VALUE OF THE EIGENFUNCTION AT THE MATCHING RADIUS
C          FROM THE OUTWARDS INTEGRATION
C       UDROUT: THE VALUE OF THE DERIVATIVE OF THE EIGENFUNCTION
C          AT THE MATCHING RADIUS FROM THE OUTWARDS INTEGRATION
C       ISR(25): CONTAINS THE LAYER NUMBER OF THE LAYER CONTAINING EACH
C          SOURCE AND RECEIVER DEPTH FOR ALL THE SOURCES AND RECEIVERS
C          OR THE FIRST 25
C       SR(25): CONTAINS THE ACTUAL POSITION OF THE SOURCE OR RECEIVER
C          DEPTH IN THEIR RESPECTIVE LAYERS FOR ALL THE SOURCES AND
C          RECEIVERS OR THE FIRST 25
C       LOWER: EIGENVALUE NUMBER OF THE FIRST EIGENVALUE AND
C          EIGENFUNCTION TO BE CALCULATED
C       IUPPER: EIGENVALUE NUMBER OF THE LAST EIGENVALUE AND
C          EIGENFUNCTION TO BE CALCULATED
C       IERR: THE ERROR FLAG , IERR=0=> NO ERROR , IERR=1=>AN ERROR
C          HAS BEEN TRAPED,AN ERROR MESSAGE OUTPUTED,EXECUTION
C          STOPPED , ALSO WARNING MESSAGES MAY HAVE BEEN ISSUED ,
C          IERR=2=>A WARNING MESSAGE OUTPUTED , EXECUTION CONTINUED
C       FACTOR: THE RATIO OF THE VALUES OF THE EIGENFUNCTION AT THE
C          MATCHING RADIUS FROM THE INWARDS AND THE OUTWARDS
C          INTEGRATION
C       METHOD: FLAG TO INDICATE WHICH METHOD IS IN USE
C          METHOD=1=>THE HALVING OR BISECTION METHOD IS IN CURRENT USE
C          METHOD=2=>THE SECOND ORDER CORRECTION METHOD IS IN USE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       SET THE ERROR FLAG
C
      IERR=0
C
C       EXAMINE THE INPUT DATA FOR ERRORS
C
      NSR = NS + NR
      CALL DATACK(ZP,CP,NWL,BH,HBOT,CBOT,RHO,ALPBT,NBL,
     2ZS,ZR,NS,NR,NSR,NL,FREQ,NMODES,IERR)
      IF(IERR.EQ.1)RETURN
C
C       INTERPOLATE THE INPUT VELOCITY PROFILE AND ORGANIZE THE OTHER
C        INPUT DATA
C       FIND THE LAYER CONTAINING THE MATCHING RADIUS
C
      CALL ITPDAT(ZP,CP,NWL,H,FREQ,HBOT,CBOT,NBL,NL,
     2NSR,NS,NR,ZS,ZR,ZI,CI,NPT,ZM,ISR,SR,IERR)
      IF(IERR.EQ.1)RETURN
C
C       DETERMINE THE PARAMETERS FOR THE DO-LOOP WHICH CALCULATES THE
C        EIGENVALUES SO THAT THE EIGENVALUES REQUESTED ARE CALCULATED
C        IF THEY EXIST
C
      CALL DOPAR(ZI,CI,NL,H,NPT,ZM,RHO,NBL,NMIN,NMODES,LOWER,
     2IUPPER,WORK,IERR)
      IF(IERR.EQ.1)RETURN
C
C
C       CALCULATE THE EIGENFUNCTIONS & EIGENVALUES
C
C
      NMCAL=0
      DO 200 I=LOWER,IUPPER
      METHOD=1
      NZC=-2
      ICNT1=0
      ICNT2=0
      NZCPV=0
      DELQ=0.0
      Q=0.0
      Q1=0.0
      Q2=0.0
      K=I
C
C       OBTAIN A TRIAL VALUE FOR THE EIGENVALUE (Q)
C       INCREMENT AND CHECK THE ITERATION COUNTER FOR THE HALVING METHOD
C
  110 ICNT1=ICNT1+1
      IF(ICNT1.LE.ITMAX)GO TO 113
      CALL ERROR(1,IERR,FLOAT(ITMAX),FLOAT(K),0.0)
      GO TO 150
  113 CALL QTRIAL(NZC,K,DELQ,KND,NMODES,NZCQ1,ZA,ZAQ1,ZB,ZBQ1,Q,Q1,Q2,
     2LOWER,IERR)
      IF(IERR.EQ.1)RETURN
C
C       IF THIS IS THE FIRST ITERATION FOR THIS MODE CALCULATE THE
C        NUMBER OF ZERO CROSSINGS AND THE INTEGRATION POINTS
C        FOR Q1
C
      IF(ICNT1.NE.1)GO TO 115
      CALL TURNPT(-1,ZI,CI,NL,Q1,Z1,Z2,ZM,IERR)
      IF (IERR.EQ.1)  WRITE (IEF,*) CMAX,CMIN,Q1
      IF(IERR.EQ.1)RETURN
      CALL INTPTS(ZI,CI,NL,Z1,Z2,Q1,ZA,ZB,SUMA,SUMB,IERR)
      IF(IERR.EQ.1)RETURN
      CALL INTOUT(ZI,CI,NL,NPT,Q1,ZM,ZA,Z1,RHO,NBL,SUMA,WORK,SMOUT,
     1 NZC,DELOUT,IERR)
      IF(IERR.EQ.1)RETURN
C
      CALL INTIN(K,ZI,CI,NL,NPT,Q1,ZM,ZB,Z2,RHO,NBL,SUMB,WORK,SMOUT,
     2 DELOUT,NZC,ZMX,SMIN,UIN,UDRIN,UOUT,UDROUT,0,IERR)
      IF(IERR.EQ.1)RETURN
      CALL NORMAL(UOUT,UDROUT,UIN,UDRIN,SMIN,SMOUT,RHO,NBL,ZM,NPT,
     2FACTOR,DELQ,IERR)
      IF(IERR.EQ.1)RETURN
      NZCQ1=NZC
      ZAQ1=ZA
      ZBQ1=ZB
      IF(NZCQ1.LT.K.OR.NZCQ1.EQ.K.AND.DELQ.LT.0.0D0)
     2 CALL ERROR(43,IERR,FLOAT(K),REAL(Q1),FLOAT(NZCQ1))                 VMODES
      IF(IERR.EQ.1)RETURN
C
C       FIND THE TURNING POINTS FOR THE TRIAL EIGENVALUE Q
C
  115 CALL TURNPT(K,ZI,CI,NL,Q,Z1,Z2,ZM,IERR)
      IF(IERR.EQ.1)RETURN
C
C       CALCULATE THE POINTS AT WHICH TO BEGIN THE INTEGRATIONS
C
      CALL INTPTS(ZI,CI,NL,Z1,Z2,Q,ZA,ZB,SUMA,SUMB,IERR)
      IF(IERR.EQ.1)RETURN
C
C       PREFORM THE OUTWARDS INTEGRATION
C       COUNT THE NUMBER OF ZERO CROSSINGS
C
  120 NZCPV=NZC
      CALL INTOUT(ZI,CI,NL,NPT,Q,ZM,ZA,Z1,RHO,NBL,SUMA,WORK,SMOUT,
     2NZC,DELOUT,IERR)
      IF(IERR.EQ.1)RETURN
C
C       PREFORM THE INWARDS INTEGRATION
C       COUNT THE NUMBER OF ZERO CROSSINGS
C       DETERMINE THE MATCHING RADIUS AND THE VALUES OF THE
C        EIGENFUNCTION FROM THE INWARDS AND OUTWARDS INTEGRATION AT
C        THIS POINT
C
      CALL INTIN(K,ZI,CI,NL,NPT,Q,ZM,ZB,Z2,RHO,NBL,SUMB,WORK,SMOUT,
     2 DELOUT,NZC,ZMX,SMIN,UIN,UDRIN,UOUT,UDROUT,NZCPV,IERR)
      IF(IERR.EQ.1)RETURN
C
C       IF THE NUMBER OF ZERO CROSSINGS ARE NOT CORRECT GO BACK TO
C        OBTAIN A NEW TRIAL EIGENVALUE Q
C       IF THE NUMBER OF ZERO CROSSINGS ARE CORRECT SAVE DELQ FROM
C        THE PREVIOUS ITERATION
C
      IF(NZC.EQ.I)GO TO 116
C 7-Apr-88/DDE 6 lines
      IF (METHOD.EQ.2) THEN
        Q = Q - DELQ
        ZA = HOLZA
        ZB = HOLZB
        NZC = HOLNZC
      ENDIF
      FACTOR=UIN/UOUT
      UOUT=UOUT*FACTOR
      UDROUT=UDROUT*FACTOR
      SMOUT=SMOUT*FACTOR**2
      METHOD =1
      GO TO 110
  116 DELQPV=DELQ
C
C       NORMALIZE THE EIGENFUNCTION AT THE MATCHING RADIUS
C       CALCULATE DELQ
C
      CALL NORMAL(UOUT,UDROUT,UIN,UDRIN,SMIN,SMOUT,RHO,NBL,ZM,NPT,
     2FACTOR,DELQ,IERR)
      IF(IERR.EQ.1)RETURN
C
C       IF THE HALVING METHOD IS IN USE CHECK IF THE CONDITIONS ARE
C        MET FOR STARTING THE SECOND ORDER METHOD , IF NOT CONTINUE WITH
C        METHOD ONE
C
      IF(METHOD.EQ.2)GO TO 130
      Q=Q+DELQ
      IF(Q.GT.Q1.AND.Q.LT.Q2.AND.NZC.EQ.NZCQ1)GO TO 117
      Q=Q-DELQ
      GO TO 110
  117 METHOD=2
        HOLZA = ZA
        HOLZB = ZB
        HOLNZC = NZC
      ZA=ZAQ1
      ZB=ZBQ1
      GO TO 120
C
C       IF IN THE SECOND ORDER METHOD INCREMENT THE ITERATION COUNTER ,
C        CHECK FOR THE DESIRED ACCURACY IN Q , AND SEE IF A JUMP BACK
C        TO THE FIRST METHOD SHOULD BE MADE
C
  130 ICNT2=ICNT2+1
C       IF(DABS(DELQ/Q).LT.TOLK.AND.DABS(DELQ).GE.DABS(DELQPV))GO TO 150
      IF(DABS(DELQ/Q).LT.TOLK) GO TO 150
      IF(ICNT2.LT.ITMAX)GO TO 135
      CALL ERROR(2,IERR,FLOAT(ITMAX),FLOAT(K),0.0)
      GO TO 150
  135 Q=Q+DELQ
      IF(Q.GT.Q1.AND.Q.LT.Q2.AND.NZC.EQ.NZCQ1)GO TO 120
      Q=Q-DELQ
      METHOD=1
      GO TO 110
C
C       WHEN THE VALUE OF Q IS ACCURATE ENOUGH , NORMALIZE THE
C        EIGENFUNCTION , CALCULATE THE EIGENFUNCTION AT THE SOURCE AND
C        RECEIVER DEPTHS , OUTPUT OPTIONAL PLOTS OR PRINTS , AND
C        CALCULATE THE ATTENUATION OF THE EIGENFUNCTION
C
  150 CALL OUTPUT(K,ZI,CI,NL,NPT,H,Q,WORK,SMOUT,SMIN,FACTOR,NSR,ZS,NS,
     2    ZR,NR,ZM,ZMX,KND,ISR,SR,UN,NMODES,MAXNM,LOWER,IUPPER,NMCAL,
     3    NWL,ZP,CP,NBL,HBOT,CBOT,RHO,ALPBT,FREQ,MAXNL,AMPL,PHSE,IERR)
      IF(IERR.EQ.1)RETURN
C
C          CALCULATE ATTENUATION DUE TO BOTTOM ABSORPTION
C  [ NOTE THAT WORK(xx,2) NEEDS TO BE DIVIDED BY H TO GIVE THE DERIVATIVE. ]
      HH=DBLE(H)
      INDEX = I - LOWER + 1                                              7/07/82
      CALL ATTENU(K,ZI,CI,WORK(1,1),WORK(1,2),NL,ZA,ZB,ALPBT,
     1 RHO,NBL,Q,HH,FREQ,KNI(INDEX),IERR)                                7/07/82
      PRTWAT(INDEX) = ATNWAT
      PRTSED(INDEX) = ATNSED
      PRTSUB(INDEX) = ATNSUB
      PRTGVL(INDEX) = GRPVEL
      IF(IERR.EQ.1)RETURN
C
C          CALCULATE ATTENUATION DUE TO SURFACE SCATTERING (10/07/79)
      RK0SQ = CI(1)/HH**2
      RKN =SQRT(Q) / HH
      RHO1=RHO(0)
      UNPZ=WORK(1,2)/HH
      SIG0=ROUGH(0)
      CALL KIRKFF (SIG0,RHO1,UNPZ,RKN,RK0SQ,DELKNI)
C         IF (IER...
      KNI(INDEX) = KNI(INDEX) + DELKNI                                   7/07/82
      PRTKNI(INDEX) = DELKNI
C
C          CALCULATE ATTENUATION DUE TO BOTTOM ROUGHNESS (27/04/80)
      NWATL = NL-NBL
      RK1SQ = CI(NWATL)/HH**2
C       RKN = SQRT(Q) / HH
C       RHO1= RHO(0)
      UNZH = WORK (NWATL+1,1)
      UNPZH= WORK(NWATL+1,2)/HH * RHO(0)/RHO(1)
      SIG1 = ROUGH(1)
      CALL KIRKFB (SIG1,RHO1,UNZH,UNPZH,RKN,RK1SQ,DELKNB)
C         IF (IER....)
      KNI(INDEX) = KNI(INDEX) + DELKNB                                   7/07/82
      PRTKNB(INDEX) = DELKNB
C
  200 CONTINUE
C
C       BEFORE RETURNING TO THE CALLING PROGRAM TRANSFORM THE
C        EIGENVALUES TO THE REQUIRED DIMENSIONS
C
      HH=DPROD(H,H)
      DO 300 J=1,NMCAL
  300 KND(J)=SQRT(KND(J)/HH)
      RETURN
      END
      SUBROUTINE DATACK(ZP,CP,NWL,H,HBOT,CBOT,RHO,ALPBT,
     2NBL,ZS,ZR,NS,NR,NSR,NL,FREQ,NMODES,IERR)
      INTEGER I,IEF,IERR,ITMAX,J,K,L,NBL,NL,NMODES,NMIN,
     1    NR,NS,NSR,NWL
      REAL    ALPBT,CBOT,CP,FREQ,H,HBOT,RHO,TOLU,VMAX,
     1    VMIN,ZP,ZR,ZS,TOLK,TOLGAM
      DIMENSION ZP(NWL),CP(NWL),HBOT(NBL),CBOT(NBL),RHO(0:NBL),
     2ALPBT(NBL),ZS(NS),ZR(NR)
      COMMON/PAR/VMIN,VMAX,NMIN,ITMAX,IEF
      COMMON/TOL/TOLK,TOLU,TOLGAM
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -CHECKS ALL INPUT DATA FOR CONTRADICTIONS AND MISTAKES
C
C       INPUT VARIABLES:
C         (ALL INPUT TO NMODES)
C
C       OUTPUT VARIABLES:
C         IERR
C
C       NOTES:
C         EACH TYPE OF ERROR HAS A CODE NUMBER RECOGNIZED BY SUBROUTINE
C        ERROR . AN APROPRIATE ERROR MESSAGE IS OUTPUTED BY SUBROUTINE
C        ERROR
C         RETURNS THE RELEVENT ERROR CODE TO NMODES
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C       GO THROUGH ALL INPUT DATA , CALL ERROR IF AN ERROR MESSAGE OR
C        A WARNING MESSAGE IS NEEDED
C       DO NOT RETURN TO NMODES UNTIL ALL PARAMETERS HAVE BEEN CHECKED
C
      IF(NWL.LT.1)CALL ERROR(30,IERR,FLOAT(NWL),0.0,0.0)
      IF(NWL.EQ.1)GO TO 150
      IF(NWL.LT.1)GO TO 175
      DO 100 I=1,NWL-1
      IF(CP(I).LT.0.0)CALL ERROR(3,IERR,FLOAT(I),CP(I),ZP(I))
      IF(ZP(I).LT.0.0)CALL ERROR(4,IERR,FLOAT(I),CP(I),ZP(I))
      IF(ZP(I).GE.ZP(I+1))CALL ERROR(5,IERR,FLOAT(I),ZP(I),ZP(I+1))
  100 CONTINUE
  150         IF(H.LT.ZP(NWL))CALL ERROR(6,IERR,ZP(NWL),H,0.0)
      IF(CP(NWL).LE.0.0)CALL ERROR(3,IERR,FLOAT(NWL),CP(NWL),ZP(NWL))
      IF(ZP(NWL).LE.0.0)CALL ERROR(4,IERR,FLOAT(NWL),CP(NWL),ZP(NWL))
  175 IF(RHO(0).LE.0.0)CALL ERROR(31,IERR,RHO(0),0.0,0.0)
      IF(FREQ.LE.0.0)CALL ERROR(7,IERR,FREQ,0.0,0.0)
      IF(NBL.LT.1)CALL ERROR(32,IERR,FLOAT(NBL),0.0,0.0)
      IF(NBL.LT.1)GO TO 250
      DO 200 J=1,NBL
      IF(HBOT(J).LE.0.0.AND.J.NE.NBL)CALL ERROR(8,IERR,FLOAT(J),
     2HBOT(J),0.0)
      IF(CBOT(J).LE.0.0)CALL ERROR(9,IERR,FLOAT(J),CBOT(J),0.0)
      IF(RHO(J).LE.0.0)CALL ERROR(10,IERR,FLOAT(J),RHO(J),0.0)
      IF(ALPBT(J).LT.0.0)CALL ERROR(33,IERR,FLOAT(J),ALPBT(J),0.0)
  200 CONTINUE
  250 IF(NS.EQ.0.AND.NR.EQ.0)CALL ERROR(38,IERR,0.0,0.0,0.0)
      IF(NS.EQ.0.AND.NR.EQ.0)GO TO 450
      IF(NS.LT.0)CALL ERROR(34,IERR,FLOAT(NS),0.0,0.0)
      IF(NS.LE.0)GO TO 350
      DO 300 K=1,NS
      IF(ZS(K).LE.0.0)CALL ERROR(11,IERR,FLOAT(K),ZS(K),0.0)
      IF(ZS(K).GT.H)CALL ERROR(15,IERR,FLOAT(K),ZS(K),0.0)
  300 CONTINUE
  350 IF(NR.LT.0)CALL ERROR(35,IERR,FLOAT(NR),0.0,0.0)
      IF(NR.LE.0)GO TO 450
      DO 400 L=1,NR
      IF(ZR(L).LE.0.0)CALL ERROR(12,IERR,FLOAT(L),ZR(L),0.0)
      IF(ZR(L).GT.H)CALL ERROR(14,IERR,FLOAT(L),ZR(L),0.0)
  400 CONTINUE
  450 IF(VMIN.LT.0.0)CALL ERROR(16,IERR,VMIN,0.0,0.0)
      IF(VMAX.LT.0.0)CALL ERROR(17,IERR,VMAX,0.0,0.0)
      IF(VMAX.LE.VMIN)CALL ERROR(18,IERR,VMAX,VMIN,0.0)
      IF(NMIN.LE.0)CALL ERROR(19,IERR,FLOAT(NMIN),0.0,0.0)
      IF(TOLK.LE.0.0)CALL ERROR(20,IERR,TOLK,0.0,0.0)
      IF(ITMAX.LE.0)CALL ERROR(21,IERR,FLOAT(ITMAX),0.0,0.0)
      IF(TOLU.LE.0.0)CALL ERROR(39,IERR,TOLU,0.0,0.0)
      IF(TOLGAM.LE.0.0)CALL ERROR(40,IERR,TOLGAM,0.0,0.0)
      IF(IEF.LT.0.OR.IEF.GT.99)CALL ERROR(41,IERR,FLOAT(IEF),0.0,0.0)
      IF(NMODES.LE.0)CALL ERROR(13,IERR,FLOAT(NMODES),0.0,0.0)
      IF(NL.LE.NBL)CALL ERROR(36,IERR,FLOAT(NL),FLOAT(NBL),0.0)
      IF(NSR.NE.NS+NR)CALL ERROR(37,IERR,FLOAT(NSR),0.0,0.0)
      RETURN
      END
      SUBROUTINE DOPAR(ZI,CI,NL,H,NPT,ZM,RHO,NBL,IDOWN,NMODES,LOWER
     2,IUPPER,WORK,IERR)
      COMMON/PAR/VMIN,VMAX,NMIN,ITMAX,IEF
      COMMON/TOL/TOLK,TOLU,TOLGAM
      COMMON/DATA/OMEGA,CMIN,CMAX
      INTEGER Z1,Z2,ZA,ZB,ZM,NL,NBL
      INTEGER IBOUND,IDOWN,IEF,IERR,ITMAX,IUPPER,J,
     1    LOWER,NMODES,NMIN,NPT,NZC
      REAL DELOUT,H,TOLU,VMAX,VMIN,ZMX,TOLK,TOLGAM,RHO(0:NBL)
      DOUBLE PRECISION WORK,SMOUT,SMIN,UIN,UDRIN,UOUT,UDROUT,
     2    FACTOR,Q,DELQ,ZI,CI,CMIN,CMAX,OMEGA,V,AVMIN,
     2    AVMAX,HT,SUMA,SUMB
      DIMENSION ZI(NL),CI(NL),WORK(NL,2),V(2),IBOUND(2)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -DETERMINES THE NUMBER OF MODES TO BE CALCULATED BY
C        FINDING THE EIGENVALUE NUMBER OF THE FIRST AND LAST MODES
C        REQUESTED OR THE EIGENVALUE NUMBERS OF THE MODES AVAILABLE
C
C       INPUT VARIABLES:
C         ZI,CI,NL,NPT,ZM,RHO,NBL,IDOWN,H,NMODES
C         5-MAR-79   CALLING SEQUENCE MODIFIED: IUP REPLACED BY NMODES
C         NMODES - MAXIMUM NUMBER OF MODES TO BE CALCULATED
C
C       OUTPUT VARIABLES:
C         LOWER,IUPPER
C
C       NOTES:
C         THE NUMBER OF MODES TO BE CALCULATED DEPENDS ON VMIN & VMAX
C        AS WELL AS NMODES & NMIN
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       DETERMINE WHICH EIGENVALUES TO USE IN FINDING THE LIMITS
C        ON THE EIGENVALUE NUMBERS
C
      HT=DBLE(H)
      V(1)=CMAX
      V(2)=CMIN
      AVMIN=HT*HT*OMEGA*OMEGA/DBLE(VMIN*VMIN)
      AVMAX=HT*HT*OMEGA*OMEGA/DBLE(VMAX*VMAX)
      IF(AVMIN.GT.AVMAX)GO TO 50
      GO TO 100
  50  IF(AVMAX.GT.CMAX.AND.AVMAX.LT.CMIN)V(1)=AVMAX
      IF(AVMIN.LT.CMIN.AND.AVMIN.GT.CMAX)V(2)=AVMIN
C
C       CALCULATE THE EIGENVALUE NUMBER (THAT IS THE NUMBER OF ZERO
C        CROSSINGS) FOR THE EIGENVALUES CORRESPONDING TO THESE
C        VALUES IF NECESSARY
C
  100 DO 200 J=1,2
      Q=V(J)
      IF(Q.NE.CMIN.OR.J.NE.2)GO TO 150
      IBOUND(2)=1
      GO TO 200
  150 CALL TURNPT(-2,ZI,CI,NL,Q,Z1,Z2,ZM,IERR)
      IF(IERR.EQ.1)RETURN
      CALL INTPTS(ZI,CI,NL,Z1,Z2,Q,ZA,ZB,SUMA,SUMB,IERR)
      IF(IERR.EQ.1)RETURN
      CALL INTOUT(ZI,CI,NL,NPT,Q,ZM,ZA,Z1,RHO,NBL,SUMA,WORK,SMOUT,
     2NZC,DELOUT,IERR)
      IF(IERR.EQ.1)RETURN
      CALL INTIN(1,ZI,CI,NL,NPT,Q,ZM,ZB,Z2,RHO,NBL,SUMB,WORK,SMOUT,
     2DELOUT,NZC,ZMX,SMIN,UIN,UDRIN,UOUT,UDROUT,0,IERR)
      IF(IERR.EQ.1)RETURN
C
C       SET IBOUND(J) TO THE NUMBER OF ZERO CROSSINGS
C
      IBOUND(J)=NZC
      CALL NORMAL(UOUT,UDROUT,UIN,UDRIN,SMIN,SMOUT,RHO,NBL,ZM,NPT,
     2FACTOR,DELQ,IERR)
      IF(IERR.EQ.1)RETURN
C
C       ADJUST IBOUND(J) BY THE SIGN OF DELQ
C
      IF(DELQ.LT.0.0D0.AND.J.EQ.1)IBOUND(J)=IBOUND(J)-1
      IF(DELQ.GT.0.0D0.AND.J.EQ.2)IBOUND(J)=IBOUND(J)+1
  200 CONTINUE
C
C       ADJUST THE SMALLEST AND LARGEST ALLOWABLE EIGENVALUE NUMBERS AS
C        NECESSARY
C
      LOWER=MAX0( IBOUND(2),IDOWN )
      IUPPER=MIN0(IBOUND(1),LOWER+NMODES-1)
C
C       CHECK THAT A POSITIVE NON-ZERO NUMBER OF MODES
C        ARE TO BE CALCULATED0
C
      IF(IUPPER-LOWER.LT.0)CALL ERROR(25,IERR,FLOAT(IUPPER),FLOAT(
     2LOWER),0.0)
      RETURN
      END
      SUBROUTINE ERROR(I,IERR,A,B,C)
      COMMON/PAR/VMIN,VMAX,NMIN,ITMAX,IEF
C
      INTEGER I,IA,IB,IC,IEF,IERR,IR,ITMAX,NMIN
      REAL A,B,C,VMAX,VMIN
      LOGICAL FIRST
C
      INTEGER UNIT
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -OUTPUTS AN APPROPRIATE ERROR MESSAGE FOR ANY ERROR
C         DETECTED IN ANY OF THE SUBROUTINES OF NMODES
C
C       INPUT VARIABLES:
C         I,A,B,C
C
C       OUTPUT VARIABLES:
C         IERR
C         ALSO ERROR MESSAGES SENT TO OUTPUT UNIT IEF
C         IF IEF IS 3 (LPT:) A COPY OF THE ERROR MESSAGE IS ALSO SENT
C         TO UNIT NUMBER 5 (TTY:)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C       FIND THE APPROPRIATE ERROR CODE
C       MAKE INPUT PARAMETERS INTEGERS AS NECESSARY
C       OUTPUT A PROPER ERROR OR WARNING MESSAGE
C
      FIRST=.TRUE.
      UNIT=IEF
C
      GO TO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
     223,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43)
     2I
  1   IA=IFIX(A+SIGN(0.01,A))
      IB=IFIX(B+SIGN(0.01,B))
      WRITE(UNIT,4000)
      WRITE(UNIT,101)IA,IB
      GO TO 950
  2   IA=IFIX(A+SIGN(0.01,A))
      IB=IFIX(B+SIGN(0.01,B))
      WRITE(UNIT,4000)
      WRITE(UNIT,102)IA,IB
      GO TO 950
  3   IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,103)IA,B,C
      GO TO 900
  4   IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,104)IA,B,C
      GO TO 900
  5   IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,105)IA,B,C
      GO TO 900
  6   WRITE(UNIT,1000)
      WRITE(UNIT,106)A,B
      GO TO 900
  7   WRITE(UNIT,1000)
      WRITE(UNIT,107)A
      GO TO 900
  8   IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,108)IA,B
      GO TO 900
  9   IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,109)IA,B
      GO TO 900
  10  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,110)IA,B
      GO TO 900
  11  IA=IFIX(A+SIGN(0.01,A))
      IF (B.LT.0.)  GO TO 911
      WRITE (UNIT,2000)
      WRITE (UNIT,9111) IA,B
      GO TO 950
 911  WRITE(UNIT,1000)
      WRITE(UNIT,111)IA,B
      GO TO 900
  12  IA=IFIX(A+SIGN(0.01,A))
      IF (B.LT.0.)  GO TO 912
      WRITE (UNIT,2000)
      WRITE (UNIT,9112) IA,B
      GO TO 950
 912  WRITE(UNIT,1000)
      WRITE(UNIT,112)IA,B
      GO TO 900
  13  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,113)IA
      GO TO 900
  14  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,2000)
      WRITE(UNIT,114)IA,B
      GO TO 950
  15  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,2000)
      WRITE(UNIT,115)IA,B
      GO TO 950
  16  WRITE(UNIT,2000)
      WRITE(UNIT,116)A
      GO TO 950
  17  WRITE(UNIT,2000)
      WRITE(UNIT,117)A
      GO TO 950
  18  WRITE(UNIT,2000)
      WRITE(UNIT,118)A,B
      GO TO 950
  19  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,119)IA
      GO TO 900
  20  WRITE(UNIT,1000)
      WRITE(UNIT,120)A
      GO TO 900
  21  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,121)IA
      GO TO 900
  22  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,122)IA
      GO TO 900
  23  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,123)IA
      GO TO 900
  24  WRITE(UNIT,3000)
      WRITE(UNIT,124)A,B
      GO TO 900
  25  IA=IFIX(A+SIGN(0.01,A))
      IB=IFIX(B+SIGN(0.01,B))
      WRITE(UNIT,3000)
      WRITE(UNIT,125)IA,IB
      GO TO 900
  26  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,3000)
      IF(IA.EQ.-1)WRITE(UNIT,226)
      IF(IA.EQ.-2)WRITE(UNIT,326)
      IF(IA.GT.0)WRITE(UNIT,126)IA
      GO TO 900
  27  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,3000)
      IF(IA.EQ.-1)WRITE(UNIT,227)
      IF(IA.EQ.-2)WRITE(UNIT,327)
      IF(IA.GT.0)WRITE(UNIT,127)IA
      GO TO 900
  28  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,3000)
      IF(IA.EQ.-1)WRITE(UNIT,228)
      IF(IA.EQ.-2)WRITE(UNIT,328)
      IF(IA.GT.0)WRITE(UNIT,128)IA
      GO TO 900
  29  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,3000)
      IF(IA.EQ.-1)WRITE(UNIT,229)
      IF(IA.EQ.-2)WRITE(UNIT,329)
      IF(IA.GT.0)WRITE(UNIT,129)IA
      GO TO 900
  30  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,130)IA
      GO TO 900
  31  WRITE(UNIT,1000)
      WRITE(UNIT,131)A
      GO TO 900
  32  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,132)IA
      GO TO 900
  33  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,133)IA,B
      GO TO 900
  34  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,134)IA
      GO TO 900
  35  IA=IFIX(A+SIGN(0.01,A))
      IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,135)IA
      GO TO 900
  36  IA=IFIX(A+SIGN(0.01,A))
      IB=IFIX(B+SIGN(0.01,B))
      WRITE(UNIT,1000)
      WRITE(UNIT,136)IA,IB
      GO TO 900
  37  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,137)IA
      GO TO 900
  38  WRITE(UNIT,1000)
      WRITE(UNIT,138)
      GO TO 900
  39  WRITE(UNIT,1000)
      WRITE(UNIT,139)A
      GO TO 900
  40  WRITE(UNIT,1000)
      WRITE(UNIT,140)A
      GO TO 900
  41  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,1000)
      WRITE(UNIT,141)IA
      GO TO 900
  42  IA=IFIX(A+SIGN(0.01,A))
      WRITE(UNIT,2000)
      WRITE(UNIT,142)IA
      GO TO 950
  43  IA=IFIX(A+SIGN(0.01,A))
      IC=IFIX(C+SIGN(0.01,C))
      WRITE(UNIT,3000)
      WRITE(UNIT,143)IA,B,IC
C
C       ASSIGN A NEW VALUE TO THE ERROR FLAG IF NECESSARY
C
  900 IERR=1
      GO TO 999
  950 IR=1
      IF(IERR.NE.1)IR=2
      IERR=IR
  999 IF(.NOT.FIRST.OR.UNIT.NE.3)RETURN
      FIRST=.FALSE.
      UNIT=6
      GO TO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,
     223,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43)
     2I
C
C       FORMATS FOR ERROR AND WARNING MESSAGE OUTPUTS
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1000         FORMAT(/,'     FATAL ERROR IN INPUT DATA FROM ERROR',
     1' ROUTINE IN MODES :')
 2000         FORMAT(/,'     INPUT DATA WARNING FROM ERROR ROUTINE IN',
     1' MODES:')
 3000         FORMAT(/,'     FATAL ERROR DURING EXECUTION FROM ERROR',
     1' ROUTINE IN MODES :')
 4000 FORMAT(/,'     EXECUTION WARNING FROM ERROR ROUTINE IN MODES :')
  101 FORMAT(' A MAXIMUM OF ',I4,' ITERATIONS WERE SPECIFIED FOR ',
     2/,' THE HALVING PROCESS,THE CONDITIONS FOR SWITCHING TO THE ',
     2/,' SECOND ORDER METHOD WERE NOT MET WITHIN THE ',
     2/,' SPECIFIED NUMBER OF ITERATIONS FOR EIGENVALUE ',I4,' .')
  102 FORMAT(' A MAXIMUM OF ',I4,' ITERATIONS WERE SPECIFIED FOR ',
     2/,' THE SECOND ORDER METHOD , IN  THE PROCESS OF CALCULATING ',
     2/,' EIGENVALUE ',I4,' THE METHOD FAILED TO CONVERGE IN THE ',
     2/,' SPECIFIED NUMBER OF ITERATIONS.')
  103 FORMAT(' ENTRY ',I4,' IN THE INPUT VELOCITY PROFILE IS ',
     2/,' CP=',G16.8,' ZP=',G16.8,' NEGATIVE SOUND VELOCITIES ARE ',
     2/,' NOT PERMITTED.')
  104 FORMAT(' ENTRY ',I4,' IN THE INPUT VELOCITY PROFILE IS ',
     2/,' CP=',G16.8,' ZP=',G16.8,' NEGATIVE DEPTHS ARE ',
     2/,' NOT PERMITTED.')
  105 FORMAT(' THE INPUT VELOCITY PROFILE DEPTH ',I4,' IS ',
     2/,G16.8,' AND THE NEXT ENTRY IS ',G16.8,' THE DEPTHS MUST ',
     2/,' INCREASE.')
  106 FORMAT(' THE LAST DEPTH ENTRY IN THE INPUT VELOCITY PROFILE IS',
     2/,G16.8,' WHEREAS THE DEPTH OF THE WATER COLUMN IS ENTERED AS',
     2/,G16.8,' THE DEPTH OF THE WATER COLUMN MUST BE AT LEAST',
     2/,' AS LARGE.')
  107 FORMAT(' THE FREQUENCY ENTERED IS ',G16.8,' NEGATIVE ',
     2/,' FREQUENCIES ARE NOT ALLOWED.')
  108         FORMAT(' THE BOTTOM LAYER ',I4,' WAS ASSIGNED A HEIGHT OF',
     2/,G16.8,' NEGATIVE OR ZERO HEIGHTS ARE NOT PERMITTED.')
  109 FORMAT(' THE BOTTOM LAYER ',I4,' WAS ASSIGNED A SOUND SPEED OF',
     2/,G16.8,' NEGATIVE OR ZERO SOUND SPEEDS ARE NOT PERMITTED.')
  110 FORMAT(' THE BOTTOM LAYER ',I4,' WAS ASSIGNED A DENSITY OF ',
     2/,G16.8,' NEGATIVE OR ZERO DENSITIES ARE NOT PERMITTED.')
  111 FORMAT(' THE SOURCE DEPTH ',I4,' WAS ENTERED AS ',G16.8,
     2/,' NEGATIVE SOURCE DEPTHS ARE NOT PERMITTED.')
 9111 FORMAT(' THE SOURCE DEPTH ',I4,' WAS ENTERED AS ',G16.8)
  112 FORMAT(' THE RECEIVER DEPTH ',I4,' WAS ENTERED AS ',G16.8,
     2/,' NEGATIVE RECEIVER DEPTHS ARE NOT PERMITTED.')
 9112 FORMAT(' THE RECEIVER DEPTH ',I4,' WAS ENTERED AS ',G16.8)
  113 FORMAT(' THE NUMBER OF NORMAL MODES REQUESTED IS ',I4,
     2/,' A NEGATIVE NUMBER OF MODES IS NOT ALLOWED.')
  114 FORMAT(' THE RECEIVER ',I4,' HAS A DEPTH OF ',G16.8,
     2/,' THIS RECEIVER IS IN THE BOTTOM LAYERS.')
  115 FORMAT(' THE SOURCE ',I3,' HAS A DEPTH OF ',G16.8,
     2/,' THIS SOURCE IS IN THE BOTTOM LAYERS.')
  116 FORMAT(' THE MINIMUM PHASE VELOCITY IS ',G16.8,
     2/,' A NEGATIVE PHASE VELOCITY IS NOT ACCEPTABLE',
     2/,' THE DEFAULT VALUE WAS USED.')
  117 FORMAT(' THE MAXIMUM PHASE VELOCITY IS ',G16.8,
     2/,' A NEGATIVE PHASE VELOCITY IS NOT ACCEPTABLE',
     2/,' THE DEFAULT VALUE WAS USED.')
  118 FORMAT(' THE MAXIMUM PHASE VELOCITY IS ',G16.8,' WHEREAS',
     2/,' THE MINIMUM PHASE VELOCITY IS ',G16.8,' THE MINIMUM',
     2/,' PHASE VELOCITY MUST BE LESS THAN THE MAXIMUM ',
     2/,' PHASE VELOCITY, THE DEFAULT VALUES WERE USED.')
  119 FORMAT(' THE NUMBER OF THE MINIMUM MODE REQUIRED IS ',I4,
     2/,' THIS VALUE MUST BE GREATER THAN ZERO.')
  120 FORMAT(' THE TOLERANCE ON THE EIGENVALUES WAS SPECIFIED AS',
     2/,G16.8,' THIS VALUE MUST BE GREATER THAN ZERO.')
  121 FORMAT(' THE MAXIMUM NUMBER OF ITERATIONS PER MODE WAS ',
     2/,' SPECIFIED AS ',I4,' THIS VALUE MUST BE GREATER THAN ZERO.')
  122 FORMAT(' THE PLOTTING OPTION WAS SPECIFIED AS THE VALUE ',I4,
     2/,' THIS VALUE MUST BE GREATER OR EQUAL ZERO.')
  123 FORMAT(' THE PRINTING OPTION WAS SPECIFIED AS THE VALUE ',I4,
     2/,' THIS VALUE MUST BE ZERO OR ONE.')
  124 FORMAT(' THE VALUE OF CMAX WAS CALCULATED AS ',G16.8,
     2/,' WHILE THE VALUE OF CMIN WAS FOUND TO BE ',G16.8,
     2/,' FOR EIGENVALUES TO EXIST CMAX MUST BE LESS THAN CMIN.')
  125 FORMAT(' THE NUMBER OF THE LARGEST EIGENFUNCTION REQUIRED IS',
     2/,I4,' THE NUMBER OF THE LOWEST EIGENFUNCTION REQUIRED IS',
     2/,I4,' THE LOWEST VALUE MUST BE LESS THAN THE LARGEST VALUE.')
  126 FORMAT(' DURING THE CALCULATION OF EIGENVALUE ',I4,' THE UPPER',
     2/,' TURNING POINT WAS NOT FOUND.')
  127 FORMAT(' DURING THE CALCULATION OF EIGENVALUE ',I4,' THE LOWER',
     2/,' TURNING POINT WAS NOT FOUND.')
  128 FORMAT(' IN THE CALCULATION OF EIGENVALUE ',I4,' A TRIAL',
     2/,' EIGENVALUE Q WAS LESS THAN THE MINIMUM SOUND SPEED',
     2/,' AND THUS OUT OF RANGE.')
  129 FORMAT(' IN THE CALCULATION OF EIGENVALUE ',I4,' A TRIAL',
     2/,' EIGENVALUE Q WAS GREATER THAN THE MAXIMUM SOUND SPEED',
     2/,' AND THUS OUT OF RANGE.')
  130 FORMAT(' THE NUMBER OF WATER LAYERS WAS SPECIFIED AS ',I4,
     2/,' THIS VALUE MUST BE AT LEAST ONE.')
  131 FORMAT(' THE DENSITY OF THE WATER IN THE WATER COLUMN WAS ',
     2/,' ENTERED AS ',G16.8,' THIS VALUE MUST BE GREATER ',
     2/,' THAN ZERO.')
  132 FORMAT(' THE NUMBER OF BOTTOM LAYERS WAS SPECIFIED AS ',
     2/,I4,' THIS VALUE MUST BE AT LEAST ONE.')
  133 FORMAT(' ENTRY ',I4,' IN THE ATTENUATION ARRAY IS ',G16.8,
     2/,' THIS VALUE MUST BE GREATER THAN OR EQUAL ZERO.')
  134 FORMAT(' THE NUMBER OF SOURCES SPECIFIED IS ',I4,
     2/,' THIS VALUE MUST BE GREATER THAN  ZERO.')
  135 FORMAT(' THE NUMBER OF RECEIVERS SPECIFIED IS ',I4,
     2/,' THIS VALUE MUST BE GREATER THAN ZERO.')
  136 FORMAT(' THE SPECIFIED NUMBER OF LAYERS IS ',I4,' WHEREAS',
     2/,' THE SPECIFIED NUMBER OF BOTTOM LAYERS IS ',I4,
     2/,' NL MUST BE GREATER THAN NBL.')
  137 FORMAT(' THE NUMBER OF SOURCE AND RECEIVER DEPTHS IS GIVEN AS',
     2/,I4,' BUT THIS IS NOT EQUAL TO THE NUMBER OF SOURCES PLUS',
     2/,' THE NUMBER OF RECEIVERS.')
  138 FORMAT(' THE NUMBER OF SOURCES AND THE NUMBER OF RECIERVERS',
     2/,' WERE BOTH SPECIFIED AS ZERO.')
  139 FORMAT(' THE TOLERANCE ON THE EIGENFUNCTION AT THE MATCHING',
     2/,' RADIUS (TOLU) WAS SPECIFIED AS ',G16.8,' THIS VALUE',
     2/,' MUST BE GREATER THAN ZERO.')
  140 FORMAT(' THE TOLERANCE ON GAMMA (TOLGAM) WAS SPECIFIED AS ',
     2/,G16.8,' THIS VALUE MUST BE GREATER THAN ZERO.')
  141 FORMAT(' THE DEVICE TO WHICH ERROR MESSAGES WILL BE DIRECTED',
     2/,' WAS SPECIFIED AS ',I4,' THIS NUMBER DOES NOT ',
     2/,' CORRESPOND TO AN OUTPUT DEVICE.')
  142 FORMAT(' THE DEVICE TO WHICH ERROR MESSAGES WILL BE DIRECTED',
     2/,' WAS SPECIFIED AS ',I4,' THIS NUMBER DOES NOT NECESSARILY',
     2/,' CORRESPOND TO AN OUTPUT DEVICE.')
  143 FORMAT(' DURING THE FIRST ITERATION ON EIGENVALUE ',I4,' THE',
     2/,' LOWER BOUND (Q1) ON THE TRIAL EIGENVALUE Q WAS SET AS',
     2/,G16.8,' BUT THE NUMBER OF ZERO CROSSINGS AT Q1 IS ',I4,
     2/,' THIS EIGENVALUE CANNOT BE CALCULATED IN THIS CASE EITHER',
     2/,' BECAUSE THE NUMBER OF ZERO CROSSINGS IS TOO SMALL OR',
     2/,' BECAUSE THE NUMBER OF ZERO CROSSINGS IS CORRECT AND DELQ',
     2/,' IS NEGATIVE.')
  226 FORMAT(' WHEN CALCULATING THE NUMBER OF ZERO CROSSINGS FOR',
     2/,' Q1 IN NMODES THE UPPER TURNING POINT WAS NOT FOUND.')
  227 FORMAT(' WHEN CALCULATING THE NUMBER OF ZERO CROSSINGS FOR',
     2/,' Q1 IN NMODES THE LOWER TURNING POINT WAS NOT FOUND.')
  228 FORMAT(' WHEN CALCULATING THE NUMBER OF ZERO CROSSINGS FOR',
     2/,' Q1 IN NMODES IT WAS FOUND THAT Q1 WAS LESS THAN THE',
     2/,' MINIMUM ALLOWABLE SOUND SPEED.')
  229 FORMAT(' WHEN CALCULATING THE NUMBER OF ZERO CROSSINGS FOR',
     2/,' Q1 IN NMODES IT WAS FOUND THAT Q1 WAS GREATER THAN THE',
     2/,' MAXIMUM ALLOWABLE SOUND SPEED.')
  326 FORMAT(' WHEN CALCULATING THE DO-LOOP PARAMETERS IN DOPAR',
     2/,' ONE OF THE TURNING POINTS COULD NOT BE FOUND.')
  327 FORMAT(' WHEN CALCULATING THE DO-LOOP PARAMETERS IN DOPAR',
     2/,' ONE OF THE TURNING POINTS COULD NOT BE FOUND.')
  328 FORMAT(' WHEN CALCULATING THE DO-LOOP PARAMETERS IN DOPAR'
     2/,' ONE OF THE EIGENVALUES TO BE CONSIDERED WAS OUT OF RANGE.')
  329 FORMAT(' WHEN CALCULATING THE DO-LOOP PARAMETERS IN DOPAR',
     2/,' ONE OF THE EIGENVALUES TO BE CONSIDERED WAS OUT OF RANGE.')
      END
      SUBROUTINE QTRIAL(NZC,I,DELQ,KND,NMODES,NZCQ1,ZA,ZAQ1,ZB,ZBQ1,
     2    Q,Q1,Q2,LOWER,IERR)
C         FLAGS CHANGES BY  DALE D ELLIS  NOV-78
      INTEGER I,LOWER,NMODES,NZC,NZCQ1,IERR
      COMMON/DATA/OMEGA,CMIN,CMAX
      DIMENSION KND(NMODES)
      INTEGER ZA,ZB,ZAQ1,ZBQ1
      DOUBLE PRECISION CMIN,CMAX,Q,Q1,Q2,DELQ,KND,OMEGA
C 
      DOUBLE PRECISION SAFETY
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -CALCULATES Q1,Q2,Q
C       -ADJUSTS THE NUMBER OF ZERO CROSSINGS AND THE INTEGRATION POINTS
C         FOR THE EIGENFUNCTION ASSOCIATED WITH Q1 IF Q1 HAS ITS
C         VALUE CHANGED
C
C       INPUT VARIABLES:
C         NZC,I,DELQ,KN(NMODES),NMODES,Q,Q1,Q2,NZCQ1,ZAQ1,ZBQ1,ZA,ZB
C
C       OUTPUT VARIABLES:
C         Q1,Q2,Q,NZCQ1,ZAQ1,ZBQ1
C
C       NOTES:
C         THE NEW TRIAL EIGENVALUE Q IS CALCULATED BY EITHER HALVING
C        THE INTERVAL , LINEAR INTERPOLATION , OR QUADRATIC
C        INTERPOLATION
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       IF THIS IS THE FIRST Q FOR THE EIGENVALUE I , GO TO THE
C        INTERPOLATION ROUTINES
C
C 
      SAFETY = 2.0D0
      IF(NZC.LT.-1)GO TO 200
C
C       IF THE NUMBER OF ZERO CROSSINGS OF THE EIGENFUNCTION IS
C        CORRECT , USE DELQ TO ADJUST Q1,Q2,Q
C
      IF(NZC.EQ.I)GO TO 220
C
C       IF THE NUMBER OF ZERO CROSSINGS IS NOT CORRECT , ADJUST
C        Q1,Q2,Q ACCORDINGLY
C       IF Q1 IS ALTERED ADJUST NZCQ1,ZAQ1,ZBQ1
C
      IF(NZC.GT.I)Q1=Q
      IF(NZC.LT.I)Q2=Q
      IF(Q1.NE.Q)GO TO 50
      NZCQ1=NZC
      ZAQ1=ZA
      ZBQ1=ZB
  50  Q=0.5D0*(Q1+Q2)
      RETURN
C
C       ADJUST Q1,Q2,Q USING THE SIGN OF DELQ AS A GUIDE
C       IF Q1 IS ALTERED ADJUST NZCQ1,ZAQ1,ZBQ1
C
  220 IF(DELQ.GT.0.0D0)Q1=Q
      IF(DELQ.LT.0.0D0)Q2=Q
      IF(Q1.NE.Q)GO TO 60
      NZCQ1=NZC
      ZAQ1=ZA
      ZBQ1=ZB
  60  Q=0.5D0*(Q1+Q2)
      RETURN
C
C       INITIAL TRIAL VALUE OF Q1,Q2,Q FOR EIGENVALUES 1 & 2
C
  200 IF(I.NE.LOWER.AND.I.NE.LOWER+1)GO TO 100
      Q1=CMAX
      Q2=CMIN
C 
      IF (I.EQ. LOWER+1) Q2=KND(1)
C 
      IF (I.EQ. LOWER+1) Q1=KND(1) - (2.0D0/DBLE(FLOAT(I-1))+
     1 1.0D0/DBLE(FLOAT((I-1)**2)) ) * (CMIN-KND(1) ) * SAFETY
      IF (Q1.LT.CMAX)  Q1=CMAX
      Q=0.5D0*(Q1+Q2)
      RETURN
C
C       INTERPOLATE LINEARLY TO GET INITIAL TRIAL VALUE FOR
C        EIGENVALUE 3 , IF THE INTERPOLATED Q IS NOT IN (Q1,Q2)
C        USE THE MIDPOINT OF THIS INTERVAL
C
  100 IF(I.NE.LOWER+2)GO TO 110
      Q=2.0D0*KND(2)-KND(1)
C
      Q1=KND(1)-(2.0D0/DBLE(FLOAT(I-1))+1.0D0/DBLE(FLOAT((I-1)**2)))
     1 *(CMIN-KND(2))  *  SAFETY
      IF(Q1.LT.CMAX)Q1=CMAX
      Q2=KND(2)
      IF(Q.LT.Q1.OR.Q.GT.Q2)Q=0.5D0*(Q1+Q2)
      RETURN
C
C       INTERPOLATE QUADRATICALLY TO GET THE INITIAL TRIAL VALUE
C        FOR ALL SUBSEQUENT EIGENVALUES , IF THE INTERPOLATED Q
C        IS NOT IN (Q1,Q2) USE THE MIDPOINT OF THIS INTERVAL
C
  110 Q=KND(I-LOWER)-3.0D0*KND(I-LOWER-1)+3.0D0*KND(I-LOWER-2)
C
      Q1=KND(I-LOWER)-(1.0D0/DBLE(FLOAT((I-1)**2))+2.0D0/DBLE
     2 (FLOAT(I-1)))  *(CMIN-KND(I-LOWER))  *  SAFETY
      IF(Q1.LT.CMAX)Q1=CMAX
      Q2=KND(I-LOWER+1-1)
      IF(Q.LT.Q1.OR.Q.GT.Q2)Q=0.5D0*(Q1+Q2)
      RETURN
      END
      SUBROUTINE TURNPT(K,ZI,CI,NL,Q,Z1,Z2,ZM,IERR)
      INTEGER I,IERR,J,K,NL
      COMMON/DATA/OMEGA,CMIN,CMAX
      INTEGER Z1,Z2,ZM
      DIMENSION ZI(NL),CI(NL)
      DOUBLE PRECISION ZI,CI,Q,CMIN,CMAX,OMEGA
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       THIS SUBROUTINE DOES THE FOLLOWING:
C       -CHECKS IF Q IS WITHIN THE ALLOWABLE RANGE
C       -SEARCHES THE INTERPOLATED PROFILE TO FIND THE UPPER &
C         LOWER TURNING POINTS
C
C       INPUT VARIABLES:
C         K,ZI(NL),CI(NL),NL,Q
C
C       OUTPUT VARIABLES:
C         Z1,Z2
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       CHECK IF Q IS IN THE ALLOWABLE RANGE
C
      IF(Q.GT.CMIN)CALL ERROR(28,IERR,FLOAT(K),0.0,0.0)
      IF(Q.LT.CMAX)CALL ERROR(29,IERR,FLOAT(K),0.0,0.0)
      IF(IERR.EQ.1)GO TO 400
C
C       DEFINE THE UPPER AND LOWER TURNING POINTS IF Q IS EQUAL TO
C        CMIN OR CMAX
C
      IF(Q.NE.CMIN.AND.Q.NE.CMAX)GO TO 90
      IF(Q.NE.CMIN)GO TO 50
      Z1=ZM
      Z2=ZM+1
      RETURN
   50 Z1=1
      Z2=NL
      RETURN
C
C       FIND Z1=UPPER TURNING POINT
C
  90  IF(Q.LE.CI(1))GO TO 130
      DO 100 I=1,NL-1
      IF(CI(I).LE.Q.AND.CI(I+1).GT.Q)GO TO 110
  100 IF(CI(I).GE.Q.AND.CI(I+1).LT.Q)GO TO 110
      CALL ERROR(26,IERR,FLOAT(K),0.0,0.0)
      RETURN
  110 Z1=I+1
      GO TO 200
  130 Z1=1
C
C       FIND Z2=LOWER TURNING POINT
C
  200 DO 300 J=0,NL-2
      I=NL-J
      IF(Q.LT.CI(I).AND.Q.GE.CI(I-1))GO TO 210
  300 IF(Q.GT.CI(I).AND.Q.LE.CI(I-1))GO TO 210
      CALL ERROR(27,IERR,FLOAT(K),0.0,0.0)
      RETURN
  210 Z2=I
  400 RETURN
      END
      SUBROUTINE INTPTS(ZI,CI,NL,Z1,Z2,Q,ZA,ZB,SUMA,SUMB,IERR)
      INTEGER I,NL,IERR
      INTEGER Z1,Z2,ZA,ZB
      DOUBLE PRECISION ZI,CI,Q,SUMA,SUMB,SUM
      DIMENSION ZI(NL),CI(NL)
      DATA SUM/14.0D0/
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -DETERMINES THE POINTS AT WHICH THE OUTWARDS & INWARDS
C         INTEGRATIONS ARE TO BE STARTED
C
C       INPUT VARIABLES:
C         ZI(NL),CI(NL),NL,Z1,Z2,Q
C
C       OUTPUT VARIABLES:
C         ZA,ZB,SUMA,SUMB
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       CALCULATE SUMA & FIND ZA
C
      SUMA=0.0D0
      I=Z1-1
      IF(I.EQ.0)GO TO 120
  105 SUMA=SUMA+DSQRT(DABS(CI(I)-Q))*(ZI(I+1)-ZI(I))
      IF(SUMA.GT.SUM)GO TO 130
      I=I-1
      IF(I.EQ.0)GO TO 120
      GO TO 105
  120 ZA=1
      GO TO 200
  130 SUMA=SUMA-DSQRT(DABS(CI(I)-Q))*(ZI(I+1)-ZI(I))
      ZA=I+1
C
C       CALCULATE SUMB & FIND ZB
C
  200 SUMB=0.0D0
      I=Z2
  205 IF(I.EQ.NL)GO TO 220
      SUMB=SUMB+DSQRT(DABS(CI(I)-Q))*(ZI(I+1)-ZI(I))
      IF(SUMB.GT.SUM)GO TO 210
      I=I+1
      GO TO 205
  210 SUMB=SUMB-DSQRT(DABS(CI(I)-Q))*(ZI(I+1)-ZI(I))
C XXX  ZB=I-1    STATEMENT REMOVED 14-SEPT-79  DDE
      ZB=I
      GO TO 300
  220 ZB=NL
  300 RETURN
      END
      SUBROUTINE INTOUT(ZI,CI,NL,NPT,Q,ZM,ZA,Z1,RHO,NBL,SUMA,WORK,
     2SMOUT,NZC,DELOUT,IERR)
C   FLAGS CHANGES BY DALE D ELLIS   NOV-78
      INTEGER I,ICHS,IZX,NBL,NL,NPT,NZC,IERR
      REAL DELOUT,GAM,GAM2,SSS,TOLU,TOLGAM,TOLK,RHO
      DIMENSION ZI(NL),CI(NL),RHO(0:NBL),WORK(NL,2)
      INTEGER ZA,ZM,Z1
      DOUBLE PRECISION WORK,GAMMA,GAMMA2,AI,BI,SS,SMOUT,A,B,S,C,E,RH,
     2    GSS,ZI,CI,Q,SUMA,PI
      COMMON/TOL/TOLK,TOLU,TOLGAM
      PARAMETER (PI=3.1415926535897932384626433832795D0)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -PREFORMS THE OUTWARDS INTEGRATION , TO DETERMINE THE
C         EIGENFUNCTION & ITS DERIVATIVE FOR THE TRIAL EIGENVALUE
C         Q , FROM THE SURFACE TO THE LAYER CONTAINING THE MATCHING
C         RADIUS
C       -CALCULATES THE INTEGRAL OF THE EIGENFUNCTION SQUARED
C         DIVIDED BY THE DENSITY
C       -COUNTS THE NUMBER OF ZERO CROSSINGS OF THE EIGENFUNCTION
C         FROM THE SURFACE TO THE LAYER CONTAINING THE MATCHING RADIUS
C
C       INPUT VARIABLES:
C         ZI(NL),CI(NL),NL,NPT,Q,ZM,ZA,RHO(0:NBL),SUMA
C
C       OUTPUT VARIABLES:
C         WORK(NL,2),SMOUT,NZC,DELOUT
C
C       NOTES:
C         THE VALUE STORED IN WORK(I,*) IS THE VALUE AT THE TOP
C        OF LAYER I
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       INITIALIZE SMOUT & NZC
C       IF THE INTEGRATION STARTS AT THE SURFACE GO TO 50
C
      NZC=1
      SMOUT=0.0D0
      IF(ZA.EQ.1)GO TO 50
C
C       ASSIGN LEADING ZEROS
C       ASSIGN THE FIRST NON-ZERO ENTRY IN THE EIGENFUNCTION
C        & ITS DERIVATIVE
C
      DO 20 I=1,ZA-1
      WORK(I,1)=0.0D0
  20  WORK(I,2)=0.0D0
      GAMMA2=CI(ZA-1)-Q
      IF(DABS(GAMMA2).LT.TOLGAM)GAMMA2=TOLGAM
      GAMMA=DSQRT(DABS(GAMMA2))
      WORK(ZA,1)=DEXP(-SUMA)
      WORK(ZA,2)=WORK(ZA,1)*GAMMA
      RH=RHO(0)
      IF(ZA-1.GT.NPT)RH=RHO(ZA-NPT-1)
      SMOUT=SMOUT+WORK(ZA,1)*WORK(ZA,1)/GAMMA/2.0D0/RH
      IF(ZA.GT.NPT)WORK(ZA,2)=WORK(ZA,2)*RHO(ZA-NPT)/RH
      GO TO 100
C
C       IF THE INTEGRATION BEGINS AT THE SURFACE CALCULATE THE
C        FIRST ENTRY IN THE EIGENFUNCTION & ITS DERIVATIVE AT THAT
C        POINT
C
  50  WORK(1,1)=0.0D0
      GAMMA2=CI(1)-Q
      GAMMA=DSQRT(DABS(GAMMA2))
      IF(GAMMA2.LT.-TOLGAM.OR.GAMMA2.GT.TOLGAM)GO TO 60
      GAMMA2=CI(2)-Q
      WORK(1,2)=1.0D0
      IF(GAMMA2.LT.-TOLGAM)WORK(1,2)=DEXP(-SUMA/ZI(2))
      GO TO 100
  60  WORK(1,2)=GAMMA
      IF(CI(1).LT.Q)WORK(1,2)=WORK(1,2)*2.0D0*DEXP(-SUMA)
C
C       IF ZA=ZM THERE ARE NO MORE CALCULATIONS
C
  100 IF(ZA.EQ.ZM)RETURN
C
C       CALCULATE THE EIGENFUNCTION
C
      RH=RHO(0)
      DO 290 I=ZA+1,ZM
      GAMMA2=CI(I-1)-Q
      SS=ZI(I)-ZI(I-1)
      GAMMA=DSQRT(DABS(GAMMA2))
      IF(I.GT.NPT)RH=RHO(I-NPT)
C
C       DECIDE IF GAMMA SQUARED IS POSITIVE NEGATIVE OR ZERO
C        AND BRANCH TO THE APPROPRIATE TYPE OF SOLUTION FOR THE
C        LAYER UNDER CONSIDERATION
C
      IF(GAMMA2.GT.TOLGAM)GO TO 210
      IF(GAMMA2.LT.-TOLGAM)GO TO 230
C
C       USE A LINEAR SOLUTION IN THE LAYER
C       CALCULATE THE CONTRIBUTION TO SMOUT FOR THE LAYER
C
      AI=WORK(I-1,1)
      BI=WORK(I-1,2)
      WORK(I,1)=AI+SS*BI
      WORK(I,2)=BI
      SMOUT=SMOUT+(AI*AI*SS+AI*BI*SS*SS+BI*BI*(SS**3)/3.0D0)/RH
      GO TO 250
C
C       USE AN OSCILLATORY SOLUTION IN THE LAYER
C       CALCULATE THE INCREMENT TO SMOUT FOR THE LAYER
C
  210 AI=WORK(I-1,2)/GAMMA
      BI=WORK(I-1,1)
      GSS=GAMMA*SS
      S=DSIN(GSS)
      C=DCOS(GSS)
      WORK(I,1)=AI*S+BI*C
      WORK(I,2)=GAMMA*(AI*C-BI*S)
      SMOUT=SMOUT+SS/2.0D0/RH*((AI*AI+BI*BI)+S*C*(BI*BI-AI*AI)
     2/GSS+2.0D0*AI*BI*S*S/GSS)
      GO TO 250
C
C       USE AN EXPONENTIAL SOLUTION IN THE LAYER
C       CALCULATE SMOUT IN THE LAYER
C
  230 AI=0.5D0*(WORK(I-1,1)+WORK(I-1,2)/GAMMA)
      BI=0.5D0*(WORK(I-1,1)-WORK(I-1,2)/GAMMA)
      GSS=GAMMA*SS
      E=DEXP(GSS)
      WORK(I,1)=AI*E+BI/E
      WORK(I,2)=GAMMA*(AI*E-BI/E)
      SMOUT=SMOUT+SS/2.0D0/RH/GSS*(AI*AI*(E*E-1)+BI*BI*(1-1/E/E)+
     24.0D0*AI*BI*GSS)
C
C       IF THERE IS A CHANGE OF DENSITY IN THE NEXT LAYER
C        MULTIPLY THE DERIVATIVE BY THE DENSITY RATIO
C       IF WE ARE AT THE LAYER CONTAINING THE MATCHING RADIUS
C        CALCULATE DELOUT
C
  250 IF(I.GT.NPT)WORK(I,2)=WORK(I,2)*RHO(I-NPT)/RHO(I-NPT-1)
      IF(I.EQ.ZM)DELOUT=SNGL(DATAN2(WORK(I,1),WORK(I,2)/RH))
C
      IF (I.EQ.ZM) DELOUT=DELOUT + PI
  290         CONTINUE
C
C       COMMENCE WITH COUNTING THE NUMBER OF ZERO CROSSINGS
C
      DO 400 I=ZA,ZM-1
      SSS=SNGL(ZI(I+1)-ZI(I))
      GAM2=SNGL(CI(I)-Q)
      GAM=SQRT(ABS(GAM2))
      A=WORK(I+1,1)
      B=WORK(I,1)
C
C       IF A OR B IS ZERO SET IT TO + OR - 1 DEPENDING ON THE SIGN
C        OF THE DERIVATIVE AT THAT POINT
C
      IF(A.NE.0.0D0)GO TO 360
      A=1.0D0
      IF(WORK(I+1,2).LT.0.0D0)A=-A
  360 IF(B.NE.0.0D0)GO TO 370
      B=1.0D0
      IF(WORK(I,2).LT.0.0D0)B=-B
C
C       CHECK FOR A CHANGE IN THE SIGN OF THE EIGENFUNCTION BETWEEN
C        THE TOP & BOTTOM OF THE LAYER
C
  370 ICHS=0
      IF(A.GT.0.0D0.AND.B.LT.0.0D0.OR.B.GT.0.0D0.AND.A.LT.0.0D0)ICHS=1
C
C       FIND THE NUMBER OF ZERO CROSSINGS IF IN AN EXPONENTIAL REGION
C        OR A LINEAR REGION
C
      IF(GAM2.GT.TOLGAM)GO TO 390
      IF(ICHS.EQ.1)NZC=NZC+1
      GO TO 400
C
C       FIND THE NUMBER OF ZERO CROSSINGS IF IN AN OSCILLATORY REGION
C
  390 IZX = GAM*SSS/PI
      IF((IZX/2)*2.EQ.IZX.AND.ICHS.EQ.1.OR.(IZX/2)*2.NE.IZX.AND.
     2ICHS.EQ.0)IZX=IZX+1
      NZC=NZC+IZX
  400 CONTINUE
      RETURN
      END
      SUBROUTINE INTIN(M,ZI,CI,NL,NPT,Q,ZM,ZB,Z2,RHO,NBL,SUMB,WORK,
     2 SMOUT,DELOUT,NZC,ZMX,SMIN,UIN,UDRIN,UOUT,UDROUT,NZCPV,IERR)
      INTEGER I,ICHS,INC,ISTART,IZX,J,M,NBL,NL,NPT,NZC,NZCPV
      REAL DELIN,DELOUT,GAM,GAM2,SSS,TOLU,XMATCH,ZMX,TOLGAM,TOLK,RHO
      DIMENSION ZI(NL),CI(NL),RHO(0:NBL),WORK(NL,2)
      INTEGER ZM,ZB,Z2,IERR
      DOUBLE PRECISION WORK,GAMMA,GAMMA2,AI,BI,SS,SMIN,A,B,S,C,E,RH,
     2    GSS,RHPREV,UOUT,UDROUT,UIN,UDRIN,SAVE1,SAVE2,ZI,CI,Q,
     2    SUMB,STERM, SMOUT,PI
      COMMON/TOL/TOLK,TOLU,TOLGAM
      PARAMETER (PI=3.1415926535897932384626433832795D0)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -PREFORMS THE INWARDS INTEGRATION , TO DETERMINE THE
C         EIGENFUNCTION & ITS DERIVATIVE FOR THE TRIAL EIGENVALUE
C         Q , FROM THE LOWEST LAYER UP TO THE MATCHING RADIUS
C       -CALCULATES THE INTEGRAL OF THE EIGENFUNCTION SQUARED
C         DIVIDED BY THE DENSITY
C       -COUNTS THE NUMBER OF ZERO CROSSINGS OF THE EIGENFUNCTION
C         FROM THE LOWEST LAYER TO THE MATCHING RADIUS
C       -DETERMINES THE ACTUAL VALUE OF THE MATCHING RADIUS AND
C         CALCULATES THE EIGENFUNCTION & ITS DERIVATIVE FOR
C         BOTH THE INWARDS & OUTWARDS INTEGRATION AT THIS POINT
C
C       INPUT VARIABLES:
C         ZI(NL),CI(NL),NL,Q,ZM,ZB,Z2,RHO(0:NBL),NBL,SUMB,NZC,DELOUT,M
C         NPT,NZCPV
C
C       OUTPUT VARIABLES:
C         WORK(NL,2),SMIN,NZC,UIN,UDRIN,UOUT,UDROUT,ZMX
C
C       NOTES:
C         THE VALUE STORED IN WORK(I,*) IS THE VALUE AT THE TOP
C        OF LAYER I
C         UIN CONTAINS THE VALUE OF THE EIGENFUNCTION AT THE MATCHING
C        RADIUS CALCULATED DURING THE INWARDS INTEGRATION , UOUT
C        CONTAINS THE VALUE CALCULATED DURING THE OUTWARDS INTEGRATION
C         SIMILARILY UDRIN CONTAINS THE VALUE OF THE DERIVATIVE OF
C        THE EIGENFUNCTION AT THE MATCHING RADIUS CALCULATED DURING THE
C        INWARDS INTEGRATION , WHILE UDROUT CONTAINS THE VALUE
C        CALCULATED DURING THE OUTWARDS INTEGRATION
C         THE MATRIX WORK(NL,2) CONTAINS ENTRIES IN THE FIRST ZM PLACES
C        AS CALCULATED IN SUBROUTINE INTOUT , THESE VALUES ARE NOT
C        ALTERED IN THIS SUBROUTINE
C         NZC AS AN INPUT VARIABLE CONTAINS THE NUMBER OF ZERO
C        CROSSINGS OF THE CALCULATED EIGENFUNCTION AS COUNTED
C        DURING THE OUTWARDS INTEGRATION , AS AN OUTPUT VARIABLE
C        OF THIS SUBROUTINE NZC WILL CONTAIN THE NUMBER OF ZERO
C        CROSSINGS OF THE ENTIRE EIGENFUNCTION
C         WE ARE GAURANTEED AN OSCILLATORY SOLUTION IN THE LAYER
C        CONTAINING THE MATCHING RADIUS
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       INITIALIZE SMIN
C       IF THE INTEGRATION STARTS IN THE LOWEST LAYER GO TO 50
C
      SMIN=0.0D0
      IF(ZB.EQ.NL)GO TO 50
C
C       ASSIGN ANY NECESSARY LEADING ZEROS
C
      DO 20 I=ZB+1,NL
      WORK(I,1)=0.0D0
  20  WORK(I,2)=0.0D0
C
C       ASSIGN THE FIRST NON-ZERO ENTRY IN THE EIGENFUNCTION &
C        ITS DERIVATIVE
C       CALCULATE THE CONTRABUTION TO THE INTEGRAL FROM THE
C        DECAYING EXPONENTIAL
C
  50  RH=RHO(0)
      IF(ZB.GT.NPT)RH=RHO(ZB-NPT)
      GAMMA2=CI(ZB)-Q
      IF(DABS(GAMMA2).LT.TOLGAM)GAMMA2=TOLGAM
      GAMMA=DSQRT(DABS(GAMMA2))
      WORK(ZB,1)=DEXP(-SUMB)
      WORK(ZB,2) = -WORK(ZB,1) * GAMMA
      SMIN=SMIN+WORK(ZB,1)*WORK(ZB,1)/2.0D0/GAMMA/RH
C
C       CALCULATE THE EIGENFUNCTION
C
      SAVE1=WORK(ZM,1)
      SAVE2=WORK(ZM,2)
      INC=ZB+ZM-1
      DO 290 J=ZM,ZB-1
      I=INC-J
      GAMMA2=CI(I)-Q
      SS=ZI(I+1)-ZI(I)
      GAMMA=DSQRT(DABS(GAMMA2))
      RHPREV=RHO(0)
      IF(I+1.GT.NPT)RHPREV=RHO(I-NPT+1)
      RH=RHO(0)
      IF(I.GT.NPT)RH=RHO(I-NPT)
C
C       DECIDE IF GAMMA2 IS POSITIVE NEGATIVE OR ZERO , AND BRANCH
C        TO THE APPROPRIATE TYPE OF SOLUTION FOR THE LAYER UNDER
C        CONSIDERATION
C
      IF(GAMMA2.GT.TOLGAM)GO TO 210
      IF(GAMMA2.LT.-TOLGAM)GO TO 230
C
C       USE A LINEAR SOLUTION IN THE LAYER
C       CALCULATE THE CONTRABUTION TO SMIN FOR THE LAYER
C
      AI=WORK(I+1,1)-WORK(I+1,2)*RH/RHPREV*SS
      BI=WORK(I+1,2)*RH/RHPREV
      WORK(I,1)=AI
      WORK(I,2)=BI
      STERM =  (AI*AI*SS+AI*BI*SS*SS+BI*BI*(SS**3)/3.0D0)/RH
      SMIN = SMIN + STERM
      GO TO 290
C
C       USE AN OSCILLATORY SOLUTION IN THE LAYER
C       CALCULATE THE INCREMENT TO SMIN FOR THE LAYER
C
  210 GSS=GAMMA*SS
      C=DCOS(GSS)
      S=DSIN(GSS)
      AI=WORK(I+1,1)*S+WORK(I+1,2)*RH/RHPREV*C/GAMMA
      BI=WORK(I+1,1)*C-WORK(I+1,2)*RH/RHPREV*S/GAMMA
      WORK(I,1)=BI
      WORK(I,2)=AI*GAMMA
      STERM =  SS/2.0D0/RH*((AI*AI+BI*BI)+S*C*(BI*BI-AI*AI)/GSS+
     22.0D0*AI*BI*S*S/GSS)
      SMIN = SMIN + STERM
      GO TO 290
C
C       USE AN EXPONENTIAL SOLUTION IN THE LAYER
C       CALCULATE SMIN IN THE LAYER
C
  230 GSS=GAMMA*SS
      E=DEXP(GSS)
      AI=(WORK(I+1,1)+WORK(I+1,2)*RH/RHPREV/GAMMA)/2.0D0/E
      BI=(WORK(I+1,1)-WORK(I+1,2)*RH/RHPREV/GAMMA)*E/2.0D0
      WORK(I,1)=AI+BI
      WORK(I,2)=GAMMA*(AI-BI)
      STERM =  SS/2.0D0/RH/GSS*(AI*AI*(E*E-1.0D0) +
     2  BI*BI*(1.0D0-1.0D0/E/E) + 4.0D0*AI*BI*GSS)
      SMIN = SMIN + STERM
  290 CONTINUE
      DELIN=SNGL(DATAN2(WORK(ZM,1),WORK(ZM,2)/RH))
      IF (DELIN.LT.0.) DELIN = DELIN + PI
C
C       CALL XMATCH TO DETERMINE ZMX
C
      IF(NZCPV.NE.M)ZMX=XMATCH(DELIN,DELOUT,GAMMA,SS)
      ISTART=ZM
      IF(ZMX.NE.0.0)ISTART=ISTART+1
C
C       ASSIGN VALUES TO UIN,UOUT,UDROUT,UDRIN IF ZMX=0.0
C
      IF(ZMX.NE.0.0)GO TO 310
      UIN=WORK(ZM,1)
      UDRIN=WORK(ZM,2)
      UOUT=SAVE1
      UDROUT=SAVE2
      GO TO 350
C
C       CALCULATE UOUT,UDROUT IF ZMX IS NOT EQUAL TO ZERO
C       ADJUST SMOUT IF ZMX IS NOT EQUAL TO ZERO
C
  310 WORK(ZM,1)=SAVE1
      WORK(ZM,2)=SAVE2
      GAMMA=DSQRT(DABS(CI(ZM)-Q))
      SS=DBLE(ZMX)
      RH=RHO(0)
      IF(ZM.GT.NPT)RH=RHO(ZM-NPT)
      AI=WORK(ZM,2)/GAMMA
      BI=WORK(ZM,1)
      GSS=GAMMA*SS
      S=DSIN(GSS)
      C=DCOS(GSS)
      UOUT=AI*S+BI*C
      UDROUT=GAMMA*(AI*C-BI*S)
C       IF(ZM.GT.NPT.AND.SS.GE.ZI(ZM+1)-ZI(ZM))UDROUT=UDROUT*RHO(ZM-NPT
C       2+1)/RHO(ZM-NPT)
      SMOUT=SMOUT+SS/2.0D0/RH*((AI*AI+BI*BI)+S*C*(BI*BI-AI*AI)/GSS+
     22.0D0*AI*BI*S*S/GSS)
C
C       CALCULATE UIN,UDRIN IF ZMX IS NOT EQUAL TO ZERO
C       ADJUST SMIN IF ZMX IS NOT EQUAL TO ZERO
C
      SS=ZI(ZM+1)-ZI(ZM)-SS
      IF(SS.GT.0.0D0)GO TO 320
      UIN=WORK(ZM+1,1)
      UDRIN = WORK(ZM+1,2)
      IF (ZM.GE.NPT) UDRIN=UDRIN *RHO(ZM-NPT)/RHO(ZM-NPT+1)
      SMIN = SMIN - STERM
      GO TO 330
  320 RHPREV=RHO(0)
      IF(ZM+1.GT.NPT)RHPREV=RHO(ZM+1-NPT)
      GSS=GAMMA*SS
      C=DCOS(GSS)
      S=DSIN(GSS)
      AI=WORK(ZM+1,1)*S+WORK(ZM+1,2)*RH/RHPREV*C/GAMMA
      BI=WORK(ZM+1,1)*C-WORK(ZM+1,2)*RH/RHPREV*S/GAMMA
      UIN=BI
      UDRIN=AI*GAMMA
      SMIN=SMIN-SS/2.0D0/RH*((AI*AI+BI*BI)+S*C*(BI*BI-AI*AI)/GSS+
     22.0D0*AI*BI*S*S/GSS)
C
C       COUNT THE NUMBER OF ZERO CROSSINGS
C
C       COUNT THE NUMBER OF ZERO CROSSINGS IN LAYER ZM IF ZMX IS NOT
C        EQUAL TO ZERO
C
  330 GAM=SQRT(ABS(SNGL(CI(ZM)-Q)))
      A=WORK(ZM,1)
      B=UOUT
      SSS=ZMX
      ICHS=0
      IF(A.GT.0.0D0.AND.B.LT.0.0D0.OR.B.GT.0.0D0.AND.A.LT.0.0D0)
     2ICHS=1
      IZX=GAM*SSS/PI
      IF((IZX/2)*2.EQ.IZX.AND.ICHS.EQ.1.OR.(IZX/2)*2.NE.IZX.AND.
     2ICHS.EQ.0)IZX=IZX+1
      NZC=NZC+IZX
      A=UIN
      B=WORK(ZM+1,1)
      SSS=SNGL(ZI(ZM+1)-ZI(ZM))-ZMX
      IF(SSS.LE.0.0D0)GO TO 350
      ICHS=0
      IF(A.GT.0.0D0.AND.B.LT.0.0D0.OR.B.GT.0.0D0.AND.A.LT.0.0D0)
     2ICHS=1
      IZX=GAM*SSS/PI
      IF((IZX/2)*2.EQ.IZX.AND.ICHS.EQ.1.OR.(IZX/2)*2.NE.IZX.AND.
     2ICHS.EQ.0)IZX=IZX+1
      NZC=NZC+IZX
C
C       COUNT THE NUMBER OF ZERO CROSSINGS IN LAYER ZM IF ZMX IS EQUAL
C        TO ZERO AND IN ALL OTHER LAYERS DOWN TO THE POINT AT WHICH
C        THE INWARDS INTEGRATION STARTED
C
  350 DO 400 I=ISTART,ZB-1
      SSS=SNGL(ZI(I+1)-ZI(I))
      GAM2=SNGL(CI(I)-Q)
      GAM=SQRT(ABS(GAM2))
      A=WORK(I+1,1)
      B=WORK(I,1)
C
C       IF A OR B IS ZERO SET IT TO + OR - 1 DEPENDING ON THE SIGN
C        OF THE DERIVATIVE AT THAT POINT
C
      IF(A.NE.0.0D0)GO TO 360
      A=1.0D0
      IF(WORK(I+1,2).LT.0.0D0)A=-A
  360 IF(B.NE.0.0D0)GO TO 370
      B=1.0D0
      IF(WORK(I,2).LT.0.0D0)B=-B
C
C       CHECK FOR A CHANGE IN THE SIGN OF THE EIGENFUNCTION BETWEEN
C        THE TOP & BOTTOM OF THE LAYER
C
  370 ICHS=0
      IF(A.GT.0.0D0.AND.B.LT.0.0D0.OR.B.GT.0.0D0.AND.A.LT.0.0D0)ICHS=1
C
C       FIND THE NUMBER OF ZERO CROSSINGS IF IN AN EXPONENTIAL REGION
C        OR A LINEAR REGION
C
      IF(GAM2.GT.TOLGAM)GO TO 390
      IF(ICHS.EQ.1)NZC=NZC+1
      GO TO 400
C
C       FIND THE NUMBER OF ZERO CROSSINGS IF IN AN OSCILLATORY REGION
C
  390 IZX=GAM*SSS/PI
      IF((IZX/2)*2.EQ.IZX.AND.ICHS.EQ.1.OR.(IZX/2)*2.NE.IZX.AND.
     2ICHS.EQ.0)IZX=IZX+1
      NZC=NZC+IZX
  400 CONTINUE
      RETURN
      END
      FUNCTION XMATCH(DELIN,DELOUT,GAMMA,SS)
      REAL AMX,AMX1,AMXP,D1,D2,DELIN,DELOUT,E1,E2,FM1,FM2,FMX,
     1    FMXP,GAMI,GH,HI,TOLU,XMATCH,TOLK,TOLGAM
      DOUBLE PRECISION GAMMA,SS,PI,PIBY2
      COMMON/TOL/TOLK,TOLU,TOLGAM
      PARAMETER (PI=3.1415926535897932384626433832795D0,PIBY2=PI/2)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS FUNCTION DOES THE FOLLOWING:
C       -CALCULATES THE OPTIMUM LOCATION OF THE MATCHING RADIUS IN THE
C         LAYER ZM
C
C       INPUT VARIABLES:
C         DELIN,DELOUT,GAMMA,SS
C
C       OUTPUT VARIABLES:
C         ZMX
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      GAMI=SNGL(GAMMA)
      HI=SNGL(SS)
      XMATCH=0.0
      D1=AMOD(DELIN,SNGL(PI))
      D2=AMOD(DELOUT,SNGL(PI))
      IF(D1.GT.TOLU.AND.D2.GT.TOLU.AND.(PI-D1).GT.TOLU.AND.(PI-D2).GT.
     2TOLU)RETURN
      E1=MIN(PI-D1,PI-D2)
      E2=MAX(PI-D1,PI-D2)
      AMX=0.5*(E1+E2)
      FMX=0.5*(E2-E1)
      AMXP=0.5*(E1+PI+E2)
      IF(AMXP.GT.PI)AMXP=AMXP-PI
      FMXP=PIBY2-FMX
      GH=GAMI*HI
      IF(GH.GE.AMX.AND.FMX.GE.FMXP)GO TO 10
      IF(GH.GE.AMXP.AND.FMXP.GE.FMX)GO TO 12
C
C       GH IS LESS THAN AMX & AMXP
C
      FM1=AMIN1(E1,SNGL(PI-E2))
      AMX1=AMIN1(AMX,AMXP)
      IF(GH.LT.AMX1)GO TO 16
C
C       GH IS BETWEEN AMX & AMXP
C
      IF(E1.GE.AMX1)FM2=ABS(GH-E1)
      IF(E1.LT.AMX1)FM2=ABS(GH-E2)
      IF(FM2.GT.FM1.AND.FM2.GT.AMIN1(FMX,FMXP))XMATCH=HI
      IF(AMIN1(FMX,FMXP).GT.FM1.AND.AMIN1(FMX,FMXP).GT.FM2)XMATCH=
     2AMX1
      RETURN
  10  XMATCH=AMX/GAMI
      RETURN
  12  XMATCH=AMXP/GAMI
      RETURN
  16  IF(E1.GT.AMX1)GO TO 18
      FM2=ABS(GH-E1)
      IF(FM2.GT.FM1)XMATCH=HI
      RETURN
  18  FM2=GH-E2+PI
      IF(FM2.GT.FM1)XMATCH=HI
      RETURN
      END
      SUBROUTINE NORMAL(UOUT,UDROUT,UIN,UDRIN,SMIN,SMOUT,RHO,NBL,ZM,
     2NPT,FACTOR,DELQ,IERR)
      INTEGER NBL,NPT,IERR,ZM
      REAL RHO(0:NBL)
      DOUBLE PRECISION UOUT,UDROUT,UIN,UDRIN,SMIN,SMOUT,FACTOR,RH,DELQ
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -NORMALIZES THE VALUES OF THE EIGENFUNCTION AT THE
C         MATCHING RADIUS
C       -CALCULATES DELQ
C
C       INPUT VARIABLES:
C         UOUT,UDROUT,UIN,UDRIN,SMIN,SMOUT,RHO(0:NBL),NBL,ZM
C
C       OUTPUT VARIABLES:
C         FACTOR,DELQ,UOUT,UDROUT,SMOUT
C
C       NOTES:
C         UOUT,UDROUT,SMOUT ARE INPUTED AS PREVIOUSLY CALCULATED
C        AND ARE OUTPUTED IN NORMALIZED FORM
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       NORMALIZE UOUT,UDROUT,SMOUT
C
      FACTOR=UIN/UOUT
      UOUT=FACTOR*UOUT
      UDROUT=FACTOR*UDROUT
      SMOUT=FACTOR*FACTOR*SMOUT
C
C       CALCULATE DELQ
C
      RH=RHO(0)
        IF(ZM.GT.NPT)RH=RHO(ZM-NPT)
      DELQ=UIN/RH*(UDRIN-UDROUT)/(SMIN+SMOUT)
      RETURN
      END
        SUBROUTINE ITPDAT(ZP,CP,NWL,H,FREQ,HBOT,CBOT,
     2NBL,NL,NSR,NS,NR,ZS,ZR,ZI,CI,NPT,ZM,ISR,SR,IERR)
C
C  MODIFICATION TO BRIAN LEVERMAN'S PROGRAM TO MAKE OUTPUT CORRESPOND TO
C   BARTBERGER-ACKLER INTERPOLATION
C
C  MODIFIED     21-NOV-78
C  MODIFIED BY  DALE D ELLIS   DREA/AM  RM/250  EXT/155  DARTMOUTH N.S.
C
C  THE INTERPOLATION IS DONE IN SUBROUTINE LINEAR
C
      INTEGER I,IERR,ISR,J,K,LIM,NBL,NL,NPT,NR,NS,NSR,NUM,NWL
      REAL CBOT,CP,FREQ,H,HBOT,HL,ZP,ZR,ZRR,ZS,ZSS
      INTEGER ZM
      DIMENSION ZP(NWL),CP(NWL),HBOT(NBL),CBOT(NBL)
     2,ZS(NS),ZR(NR),ISR(25),SR(25),ZI(NL),CI(NL)
      DOUBLE PRECISION ZI,CI,CMIN,CMAX,OMEGA,SR,HDOUB,PI
 
      COMMON/DATA/OMEGA,CMIN,CMAX
      PARAMETER (PI=3.1415926535897932384626433832795D0)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -CALCULATES OMEGA,CMIN,CMAX
C       -INTERPOLATES THE INPUT VELOCITY PROFILE IN THE WATER
C         COLUMN TO THE DESIRED NUMBER OF PLACES
C       -NORMALIZES ALL VELOCITY & DEPTH ENTRIES
C       -ORGANIZES THE DENSITY ARRAY
C       -ASSIGNS ZM AS THE LAYER OF MINIMUM SOUND SPEED
C       -CREATES ISR(25),SR(25)
C
C       INPUT VARIABLES:
C         ZP(NWL),CP(NWL),NWL,H,FREQ,HBOT(NBL),CBOT(NBL),
C         NBL,NL,NSR,NS,NR,ZS(NS),ZR(NR)
C
C       OUTPUT VARIABLES:
C         ZI(NL),CI(NL),NPT,ISR(25),SR(25),ZM,
C          & (IN COMMON) OMEGA,CMIN,CMAX
C
C       NOTES:
C         LINEAR INTERPOLATION IS USED ON THE INPUT VELOCITY
C        PROFILE
C         THE ARRAYS ISR AND SR ARE DIMENSIONED TO 25 , AND WILL
C        CONTAIN INFORMATION ABOUT THE FIRST 25 SOURCE OR RECIEVERS
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       CALCULATE OMEGA & NPT
C
C
        OMEGA= 2.0D0 * PI * DBLE(FREQ)
C
      HDOUB=DBLE(H)
        NPT=NL-NBL
C
C          INTERPOLATE THE SOUND SPEED PROFILE A LA BARTBERGER-ACKLER
C
      CALL LINEAR(NWL,ZP,CP,NBL,HBOT,CBOT,H,OMEGA,NL,ZI,CI)
C
C       FIND THE MINIMUM VELOCITY IN THE PROFILE
C
      CMIN=0.0D0
      DO 400 I=1,NL
      IF(CI(I).LE.CMIN)GO TO 400
      CMIN=CI(I)
      ZM=I
  400 CONTINUE
      IF (ZM.EQ.1)  ZM=2
C
C       CALCULATE C-INFINITY(=CMAX)
C       CHECK THAT CMAX IS LESS THAN CMIN
C
      CMAX=CI(NL)
      IF(CMAX.GE.CMIN)CALL ERROR(24,IERR,SNGL(CMAX),SNGL(CMIN),0.0)
      IF(IERR.EQ.1)RETURN
C
C       FIND THE LAYER CONTAINING EACH SOURCE AND RECIEVER DEPTH
C       FIND THE POSITION OF THE SOURCE OR RECIEVER DEPTH IN THE LAYER
C        FOR ALL SOURCES AND RECIEVERS OR THE FIRST 25
C
C       FOR THE SOURCES
C
      HL=H/FLOAT(NPT)
      NUM=MIN0(25,NS)
      IF(NS.EQ.0)GO TO 605
      DO 600 I=1,NUM
      IF(ZS(I).GT.H)GO TO 510
      ISR(I)=IFIX(ZS(I)/HL)+1
      SR(I)=DBLE(ZS(I))/HDOUB - ZI(ISR(I))
      GO TO 600
  510 ZSS=ZS(I)/H
      DO 550 J=NPT+1,NL-1
      IF(ZSS.GE.SNGL(ZI(J)).AND.ZSS.LT.SNGL(ZI(J+1)))GO TO 560
  550 CONTINUE
      J=NL
  560 ISR(I)=J
      SR(I)=DBLE(ZS(I))/HDOUB - ZI(J)
  600 CONTINUE
C
C       FOR THE RECIEVERS IF THE NUMBER OF SOURCES IS LESS THAN 25
C
      IF(NUM.EQ.25)RETURN
  605 LIM=MIN0(25,NSR)
      IF (NR.EQ.0)  GO TO 705
      DO 700 J=NUM+1,LIM
      I=J-NUM
      IF(ZR(I).GT.H)GO TO 610
      ISR(J)=IFIX(ZR(I)/HL)+1
      SR(J)=DBLE(ZR(I))/HDOUB - ZI(ISR(J))
      GO TO 700
  610 ZRR=ZR(I)/H
      DO 650 K=NPT+1,NL-1
      IF(ZRR.GE.SNGL(ZI(K)).AND.ZRR.LT.SNGL(ZI(K+1)))GO TO 660
  650 CONTINUE
      K=NL
  660 ISR(J)=K
      SR(J)=DBLE(ZR(I))/HDOUB -ZI(K)
  700 CONTINUE
C
  705 CONTINUE
C
C
      RETURN
      END
      SUBROUTINE OUTPUT(K,ZI,CI,NL,NPT,H,Q,WORK,SMOUT,SMIN,FACTOR,NSR,
     2ZS,NS,ZR,NR,ZM,ZMX,KND,ISR,SR,UN,NMODES,MXNM,LOWER,IUPPER,NMCAL,
     3NWL,ZP,CP,NBL,HBOT,CBOT,RHO,ALPBT,FREQ,MAXNL,AMPL,PHSE,
     4IERR)
      INTEGER I,I2PI,IB,IEF,IERR,INDEX,ISR,ITMAX,IUPPER,MAXNL,
     1    J,K,LAYER,LIM,LOWER,MXNM,NBL,NL,NMODES,NMCAL,NMIN,NPT,NR,NS,
     2    NSR,NWAT,NWL,LUO
      REAL AA,ALPBT,AP,AWKB,CBOT,CP,DEG,DEP,DEPTH,FREQ,G1,G2,GF,
     1    GFA,GFP,H,HBOT,HL,PHI,PHIP,PWKB,RHO,TOLU,UN,VMAX,VMIN,
     2    ZMX,ZP,ZR,ZS,TOLK,TOLGAM,AMPL(MAXNL,NMODES),
     3    PHSE(MAXNL,NMODES)
      DOUBLE PRECISION WORK,SMOUT,SMIN,FACTOR,G,GAMMA2,GAMMA,           16/07/82
     2    GSS,A,B,E,ZI,CI,Q,KND,SR,X,PI                                 16/07/82
      DIMENSION ZI(NL),CI(NL),WORK(NL,2),ZS(NS),ZR(NR),ISR(25),SR(25),
     2    UN(MXNM,NSR),KND(NMODES),ZP(NWL),CP(NWL),CBOT(NBL),HBOT(NBL),
     3    RHO(0:NBL),ALPBT(NBL)
      INTEGER ZM
      LOGICAL EIGF,EIGV,TLFLG,ATTFLG,GVLFLG,CPFLG,PFFLG
      COMMON/PAR/VMIN,VMAX,NMIN,ITMAX,IEF
      COMMON/TOL/TOLK,TOLU,TOLGAM
      COMMON /PRTFLG/LUO,EIGF,EIGV,TLFLG,ATTFLG,GVLFLG,CPFLG,PFFLG
      PARAMETER (PI=3.1415926535897932384626433832795D0)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C          THIS SUBROUTINE DOES THE FOLLOWING:
C       -INCREMENT NMCAL
C       -NORMALIZES THE EIGENFUNCTION
C       -CALCULATES THE EIGENFUNCTION AT THE SOURCE AND RECIEVER DEPTHS
C       -PLOTS OR PRINTS THE EIGENFUNCTION AS SPECIFIED
C       -STORES THE FINAL VALUE OF THE EIGENVALUE
C
C       INPUT VARIABLES:
C         K,ZI,CI,H,NPT,NL,Q,SMOUT,SMIN,FACTOR,NSR,ZS,NS,ZR,NR,ZM,
C         ZMX,UOUT,UDROUT,UIN,UDRIN,ISR,SR,NMODES,KND,WORK,LOWER,NMCAL
C
C       OUTPUT VARIABLES:
C         UN,KN
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C       SAVE Q IN ARRAY KND
C       INCREMENT NMCAL
C
      INDEX = K - LOWER + 1                                             16/07/82
      KND(INDEX)=Q                                                      16/07/82
      NMCAL=NMCAL+1
C
C       MULTIPLY THE VALUES OF THE EIGENFUNCTION FROM THE OUTWARDS
C        INTEGRATION BY FACTOR
C
      LIM=ZM
      IF(ZMX.EQ.0.0)LIM=LIM-1
      IF(LIM.EQ.0)GO TO 125
      DO 100 I=1,LIM
      WORK(I,1)=WORK(I,1)*FACTOR
  100 WORK(I,2)=WORK(I,2)*FACTOR
C
C       NORMALIZE THE EIGENFUNCTION SO THAT THE INTEGRAL IS ONE
C
C
  125 G=1.0D0/(DSQRT((SMOUT+SMIN)*DBLE(H)))
      DO 200 I=1,NL
      WORK(I,1)=WORK(I,1)*G
  200 WORK(I,2)=WORK(I,2)*G
C
C       CALCULATE THE EIGENFUNCTION AT THE SOURCE AND RECIEVER DEPTHS
C
      HL=H/FLOAT(NPT)
      DO 400 I=1,NSR
      IF(I.GT.25)GO TO 310
      LAYER=ISR(I)
      X=SR(I)
      GO TO 350
  310 IF(I.GT.NS)GO TO 315
      DEPTH=ZS(I)
      GO TO 320
  315 DEPTH=ZR(I-NS)
  320 IF(DEPTH.GT.H)GO TO 330
      LAYER=IFIX(DEPTH/HL)+1
      X=DBLE((DEPTH-SNGL(ZI(LAYER))*H)/H)
      GO TO 350
  330 DEPTH=DEPTH/H
      DO 335 J=NPT,NL-1
      IF(DEPTH.GE.SNGL(ZI(J)).AND.DEPTH.LT.SNGL(ZI(J+1)))GO TO 340
  335 CONTINUE
      J=NL
  340 LAYER=J
      X=DBLE(DEPTH)-ZI(J)
  350 GAMMA2=CI(LAYER)-Q
      GAMMA=DSQRT(DABS(GAMMA2))
      IF(GAMMA2.GT.TOLGAM)GO TO 360
      IF(GAMMA2.LT.-TOLGAM)GO TO 370
      UN(INDEX,I)=SNGL(WORK(LAYER,1)+WORK(LAYER,2)*X)                   13/07/82
      GO TO 400
  360 GSS=GAMMA*X
      UN(INDEX,I)=SNGL(WORK(LAYER,2)/GAMMA*DSIN(GSS)+WORK(LAYER,1)*     13/07/82
     $   DCOS(GSS))                                                     13/07/82
      GO TO 400
  370 A=0.5D0*(WORK(LAYER,1)+WORK(LAYER,2)/GAMMA)
      B=0.5D0*(WORK(LAYER,1)-WORK(LAYER,2)/GAMMA)
      E=DEXP(GAMMA*X)
      UN(INDEX,I)=SNGL(A*E+B/E)                                         13/07/82
  400 CONTINUE
C
C       INSERT IN THIS SPOT THE PREPARATIONS FOR THE OPTIONAL
C        PRINTING OR PLOTTING OUTPUTS
C
      NWAT = NL-NBL
      DEG = 180./PI
      IF (EIGF) THEN
          WRITE(LUO,450)K
  450     FORMAT(//,' EIGENFUNCTION ',I5,/,
     1      4X,'IZ',5X,'DEPTH',12X,'A',12X,'PHI',13X,'AP',12X,'PHIP',
     1      13X,'U',14X,'UP')
      ENDIF
C
      I2PI = 0
      DO 500 I=1,NL
        DEP=H*ZI(I)
C          CALCULATE A MONOTONIC AMPLITUDE AND PHASE
        GF  = RHO(0)
        IF (I.GT.NWAT)  GF=GF/RHO(I-NWAT)
        AA = DSQRT (  WORK(I,1)**2 + ( GF*WORK(I,2) )**2 )
        IF (WORK(I,1).EQ.0..AND. WORK(I,2).EQ.0.) THEN
            PHI = 0.0
        ELSE
            PHI = DEG * ATAN2 ( WORK(I,1), GF*WORK(I,2) )
        ENDIF
C
C          TRY TO GET A SMOOTHER AMPLITUDE AND PHASE
        G2 = CI(I)-Q
        G1 = SQRT ( ABS(G2) )
        GFA= RHO(0)/G1
        GFP= GFA
C            IF (G1 .LT. 1.0)  GFP=1.0
C            IF (G2 .LT. 4.0)  GFA=0.5
        IF (I .GT. NWAT)  THEN
            GFA=GFA/RHO(I-NWAT)
            GFP=GFP/RHO(I-NWAT)
        ENDIF
        AP = DSQRT (  WORK(I,1)**2 + (GFA*WORK(I,2))**2 )
        IF (WORK(I,1).EQ.0..AND. WORK(I,2).EQ.0.) THEN
            PHIP = 0.0
        ELSE
            PHIP = DEG * ATAN2 ( WORK(I,1), GFP*WORK(I,2) )
        ENDIF
        IF (PHIP.LT.0.)  PHIP = PHIP + 360.
        PHIP = PHIP + 360.*I2PI
        IF (I.NE.NL)  THEN
          IF (G2.GT.TOLGAM**2)  THEN
             I2PI = PHIP/360. + G1*(ZI(I+1)-ZI(I))/(PI*2.)
              IB = 1
          ELSE
             IF (WORK(I,1).LT.0. .AND. WORK(I+1,1).GE.0.)
     1          I2PI = I2PI + 1
              IB=2
          ENDIF
        ENDIF
C          WRITE RESULTS
        IF ( MOD(K,2) .EQ. 0 )  PHIP = PHIP - 180.
        IF (EIGF) WRITE (LUO,550)  I,DEP,AA,PHI, AP,PHIP,
     1      WORK(I,1),WORK(I,2), IB
        AMPL(I,INDEX) = AP
        PHSE(I,INDEX) = PHIP
C
C       5-Apr-88: Amplitude and phase for reverberation use
          IF (G2.LE.TOLGAM**2)  THEN
            AWKB = ABS (WORK(I,1))
            IF (WORK(I,1).GE.0.)  PWKB = 90.
            IF (WORK(I,1).LT.0.)  PWKB = 270.
            IF (EIGF) WRITE (LUO,551)  AWKB, PWKB
          ENDIF
 
  500 CONTINUE
  550 FORMAT (1X,I5,5G15.7,2G15.7,I3)
  551 FORMAT (51X,2G15.7)
      RETURN
      END
      SUBROUTINE ATTENU(N,XI,VI,UN,UNP,NL,IZA,IZB,ALPBT,
     1  RHO,NBL,QN,H,FREQ,KNI,IERR)
C
C  SUBROUTINE TO CALCULATE THE IMAGINARY PART OF THE WAVE NUMBER
C   DUE TO BOTTOM ATTENUATION
C
C  AUTHOR: DALE D ELLIS
C          DEFENCE RESEARCH ESTABLISHMENT ATLANTIC
C          P.O. BOX 1012, DARTMOUTH, NS   B2Y 3Z7
C  DATE WRITTEN: 19-FEB-79
C  LAST MODIFICATION:
C  LAST EDIT   : 20-MAR-81
C
C  ARGUMENTS,
C  N            - NUMBER OF MODE (UNUSED)
C  XI(NL)       - ARRAY OF NORMALIZED DEPTHS
C  VI(NL)       - ARRAY OF NORMALIZED 'POTENTIAL'  (H*OMEGA/C(Z))**2
C  UN(NL)       - MODE FUNCTION AT DEPTHS XI(NL)
C  UNP(NL)      - DERIVATIVE OF MODE FUNCTION AT DEPTHS XI(NL)
C  NL           - TOTAL NUMBER OF LAYERS (INCLUDING BOTTOM LAYERS)
C  IZB          - LAYER AT WHICH INWARD INTEGRATION BEGINS
C  ALPBT(NBL)  - ATTENUATION IN THE BOTTOM LAYERS (DB/LENGTH-KHZ)
C  RHO(0:NBL)   - DENSITIES OF WATER COLUMN AND BOTTOM LAYERS
C  NBL          - NUMBER OF BOTTOM LAYERS
C  QN           - Q-ENERGY FOR MODE N  (I.E. EIGENVALUE)
C  H            - WATER DEPTH
C  FREQ         - FREQUENCY
C  KNI          - IMAGINARY PART OF WAVE NUMBER KN
C  IERR         - ERROR REPORTING PARAMETER (IERR=0 IF NO ERROR OCCURS)
C
      INTEGER N,NL,IZA,IZB,NBL,IERR,NWL,MIN,MAX,I,II
      REAL ATTDEP,TOLU,TOLK,TOLGAM
      REAL KNI,FREQ,ALPWAT,ALPBT(NBL),RHO(0:NBL),
     1     ATNWAT,ATNSED,ATNSUB,ATNSUR,ATNBOT,ATNSHR,GRPVEL
      DOUBLE PRECISION XI(NL),VI(NL),UN(NL),UNP(NL),QN
      DOUBLE PRECISION ZERO,HALF,DKN,UIO,UIPO,H,PI
      DOUBLE PRECISION USQINT,SUMWAT,SUMSED,SUMSUB,SUMGRP
      COMMON /TOL/ TOLK,TOLU,TOLGAM
      COMMON /ATTENS/ ATNWAT,ATNSED,ATNSUB,ATNSUR,ATNBOT,ATNSHR,GRPVEL
      DATA ZERO/0.D0/,  HALF/0.5D0/
      PARAMETER (PI=3.1415926535897932384626433832795D0)
C
      IERR=0
      NWL=NL-NBL
      DKN=ZERO
      SUMWAT = ZERO
      SUMSED = ZERO
      SUMSUB = ZERO
      SUMGRP = ZERO
C
C   CALCULATE ATTENUATION DUE TO ABSORPTION IN WATER
      MIN = IZA
      MAX = MIN0 (NWL,IZB-1)
C          ANYTHING ABOVE LAYER IZA IS IGNORED
      DO 10 I=MIN,MAX
      CALL LAYER (UN(I),UNP(I),VI(I)-QN,TOLGAM,XI(I+1)-XI(I),
     1  UIO,UIPO,USQINT,1)
      ALPWAT = ATTDEP ( SNGL(H*XI(I)), FREQ )
      SUMGRP = SUMGRP + VI(I)*USQINT
   10 SUMWAT = SUMWAT + ALPWAT * SQRT ( VI(I)/QN) * USQINT
      IF (MAX.LT.NWL)  THEN
         ALPWAT = ATTDEP ( SNGL(H*XI(I)), FREQ )
         USQINT = HALF * UN(I)**2 / SQRT (-VI(IZB)+QN)
         SUMWAT = SUMWAT + ALPWAT * SQRT (VI(IZB)/QN) * USQINT
         SUMGRP = SUMGRP + VI(IZB) * USQINT
      END IF
      SUMWAT = H / RHO(0) * SUMWAT
      SUMGRP = SUMGRP/RHO(0)
C
C   CALCULATE ATTENUATION DUE TO SEDIMENT LAYERS
   12 CONTINUE
      IF (IZB.LE.NWL) GO TO 30
      MIN = NWL + 1
      MAX = IZB-1
      IF (MIN.GT.MAX) GO TO 22
      DO 20 I=MIN,MAX
      II=I-NWL
      CALL LAYER (UN(I),UNP(I),VI(I)-QN,TOLGAM,XI(I+1)-XI(I),
     1  UIO,UIPO,USQINT,1)
      SUMGRP = SUMGRP + VI(I)*USQINT/RHO(II)
      IF (ALPBT(II).EQ.0) GO TO 20
      SUMSED = SUMSED + ALPBT(II)/RHO(II)*SQRT(VI(I)/QN)*USQINT
   20 CONTINUE
      SUMSED = SUMSED * H
      IF (MAX.EQ.NL-1) GO TO 22
C         BASEMENT LAYER IS TOO DEEP, STOP HERE
      USQINT =  HALF*UN(IZB)**2/SQRT(-VI(IZB)+QN)
      SUMGRP = SUMGRP + VI(IZB)*USQINT/RHO(IZB-NWL)
      SUMSED = SUMSED + ALPBT(IZB-NWL)/RHO(IZB-NWL)* H *
     1  SQRT(VI(IZB)/QN) * USQINT
      GO TO 30
C
C   CALCULATE ABSORPTION DUE TO BASEMENT LAYER
   22 CONTINUE
      IF (IZB.NE.NL)  IERR=1
      USQINT = HALF*UN(NL)**2/SQRT(-VI(NL)+QN)
      SUMGRP = SUMGRP + VI(NL)*USQINT/RHO(NBL)
      SUMSUB = H * ALPBT(NBL)/RHO(NBL) * SQRT (VI(NL)/QN)
     1 * USQINT
C
C   NOW ADD ALL THE ATTENUATIONS
C
   30 DKN = SUMWAT + SUMSED + SUMSUB
      ATNWAT = SUMWAT
      ATNSED = SUMSED
      ATNSUB = SUMSUB
      GRPVEL = 2.*PI*FREQ* SQRT(QN)/SUMGRP
      KNI=DKN
      RETURN
      END
C
      SUBROUTINE LINEAR (NWL,ZP,CP,NBL,HBOT,CBOT,H,OMEGA,NL,XI,VI)
C
C  INTERPOLATION OF SOUND SPEED PROFILE SO THAT 1./C**2 IS LINEAR IN
C   THE WATER
C
C  WRITTEN BY  DALE D ELLIS  DREA/AM  RM/250  EXT/155   DARTMOUTH N.S.
C  DATE WRITTEN   17-NOV-78
C  LAST MODIFICATION  20-NOV-78
C
C  OUTPUT IS SIMILAR TO THE BARTBERGER-ACKLER NORMAL MODE PROGRAM
C   DEPTHS ARE NORMALIZED SO THAT THE WATER DEPTH IS 1.
C   OUTPUT QUANTITY VI IS  (H*OMEGA/C(Z))**2
C
C  INPUT ARGUMENTS
C  I  NWL       NUMBER OF POINTS IN INPUT WATER COLUMN PROFILE
C  S  ZP(NWL)   DEPTHS OF INPUT PROFILE
C  S  CP(NWL)   SOUND SPEEDS AT DEPTHS ZP
C  I  NBL       NUMBER OF BOTTOM LAYERS
C  S  HBOT(NBL) THICKNESS OF EACH BOTTOM LAYER
C  S  CBOT(NBL) SOUND SPEED IN BOTTOM LAYERS
C  S  H         WATER DEPTH
C  D  OMEGA     ANGULAR FREQUENCY
C  I  NL        NUMBER OF LAYERS IN INTERPOLATED PROFILE
C
C  OUTPUT ARGUMENTS
C  D  XI(NL)    INTERPOLATED DEPTHS  [ XI(NPT+1)=1.D0 AT DEPTH H]
C  D  VI(NL)    OUTPUT FUNCTION  (H*OMEGA/(0.5*(C(I)+C(I+1)))**2
C
C  OTHER VARIABLES
C  I  NPT       NUMBER OF LAYERS IN WATER COLUMN
C  D  CII       INTERPOLATED SOUND SPEED AT DEPTH ZII
C  D  CI2       AVERAGE SOUND SPEED IN LAYER I AND I+1
C
C
      INTEGER I,NBL,NL,NPT,NPT1,NWL,M
      REAL CBOT,CP,EPS,H,HB,HBOT,ZP
      DIMENSION ZP(NWL),CP(NWL),HBOT(NBL),CBOT(NBL)
      DOUBLE PRECISION XI(NL),VI(NL)
      DOUBLE PRECISION OMEGA,HW,DZ,DX,ZII,SLOPE,ZPM,VM
      DATA EPS /1.E-4/
C
      NPT=NL-NBL
      NPT1=NPT+1
      HW=DBLE(H)*OMEGA
      DZ=DBLE(H)/NPT
      DX=1.0D0/NPT
C
      M=1
C
      DO 100 I=1,NPT1
      ZII=(I-1)*DZ
      IF ( ZII.LE.ZP(1) )  GO TO 50
      IF ( ZII.GE.ZP(NWL) ) GO TO 60
      IF ( ABS(ZII-ZP(M)).LT.EPS)  GO TO 70
   40 IF ( ZII.LE.ZP(M) )  GO TO 80
C
C         CALCULATE SLOPE IN NEXT DEPTH INTERVAL
      ZPM=DBLE(ZP(M))
      VM = ( HW/DBLE(CP(M)) )**2
      M=M+1
      SLOPE= ( (HW/DBLE(CP(M)))**2 -VM ) / (DBLE(ZP(M))-ZPM)
      GO TO 40
C
C          DEPTH LESS THAN ZP(1).   CONSTANT
   50 VI(I)=(HW/DBLE(CP(1)))**2
      GO TO 100
C
C          DEPTH GREATER THAN ZP(NWL).  CONSTANT
   60 VI(I)=(HW/DBLE(CP(NWL)))**2
      GO TO 100
C
C          DEPTH NEAR INPUT POINT.  EQUAL TO THAT POINT
   70 VI(I)=(HW/DBLE(CP(M)))**2
      GO TO 100
C
C          INTERPOLATION. 1./C**2  LINEAR
   80 VI(I)=VM + SLOPE*(ZII-ZPM)
C
  100 CONTINUE
C
C
      DO 105 I=1,NPT
      XI(I)=(I-1)*DX
      VI(I)=4.D0 / (1.0D0/DSQRT(VI(I)) + 1.0D0/DSQRT(VI(I+1)) )**2
  105 CONTINUE
C
C
      HB=DBLE(H)
      DO 110 I=1,NBL
      XI(NPT+I)= HB/DBLE(H)
      VI(NPT+I)=  (HW/DBLE(CBOT(I)))**2
      HB=HB+DBLE(HBOT(I))
  110 CONTINUE
C
C
      RETURN
      END
      SUBROUTINE LAYER (UIZ,UIPZ,GAMSQ,TOL,XF,UIO,UIPO,UINT,IFLAG)
C
C  EVALUATES U ITS DERIVATIVE AND INTEGRAL TO X=XF, GIVEN THE INITIAL
C   VALUES OF U, DU/DX AND THE PHASE ARGUMENT GAMMA.
C
C  WRITTEN BY: DALE D ELLIS     DEFENCE RESEARCH ESTABLISHMENT ATLANTIC
C                               DARTMOUTH, NS
C  DATE WRITTEN: 12-FEB-79
C  LAST MODIFICATION: 19-FEB-79
C
C   UIZ         - U(X) AT X=0, I.E. INITIAL VALUE OF U(X)
C   UIPZ        - INITIAL VALUE OF DU/DX
C   GAMSQ       - PHASE ARGUMENT IN THE LAYER
C   TOL         - TOLERANCE FOR LINEAR FUNCTION IN LAYER
C   XF          - FINAL VALUE OF X
C   UIO         - U EVALUATED AT X=XF
C   UIOP        - DU/DX EVALUATED AT X=XF
C   UINT        - INTEGRAL OF U**2 FROM X=0 TO X=XF
C   IFLAG       - FLAG. (IF IFLAG=0, UINT IS NOT EVALUATED)
C
C
      INTEGER IFLAG
      real tol
      DOUBLE PRECISION ZERO,ONE,TWO,THREE,GAMSQ,A,G,B,UIZ,
     1    SI,XF,CI,UIO,UIPO,UINT,E,UIPZ,HALF
      DATA ZERO/0.D0/, HALF/0.5D0/, ONE/1.0D0/, TWO/2.0D0/, THREE/3.0D0/
C
      IF (DABS(GAMSQ).LT.TOL) GO TO 30
      IF (GAMSQ.LT.ZERO)  GO TO 20
C
C          U(X)=A*SIN(G*X) + B*COS(G*X)
      G=DSQRT(GAMSQ)
      B=UIZ
      A=UIPZ/G
      SI=DSIN(G*XF)
      CI=DCOS(G*XF)
      UIO=A*SI+B*CI
      UIPO=G*(A*CI-B*SI)
      IF (IFLAG.EQ.0)  RETURN
      UINT=XF/TWO* (A**2+B**2 + SI*CI/G/XF*(B**2-A**2)
     1 + TWO*A*B*SI**2/G/XF)
      RETURN
C
C          U(X)=A*EXP(G*X) + B*EXP(-G*X)
   20 G=DSQRT(-GAMSQ)
      A=(UIZ+UIPZ/G)/TWO
      B=(UIZ-UIPZ/G)/TWO
      E=DEXP(G*XF)
      UIO=A*E + B/E
      UIPO=G*(A*E-B/E)
      IF (IFLAG.EQ.0)  RETURN
      UINT=(A**2*(E**2-ONE)/TWO + B**2*(ONE-E**(-2))/TWO
     1        + TWO*A*B*G*XF) / G
      RETURN
C
C          U(X)= A + B*X
   30 A=UIZ
      B=UIPZ
      UIO=UIZ + XF*UIPZ
      UIPO=UIPZ
      IF (IFLAG.EQ.0) RETURN
      UINT= XF*(A**2 + XF*(A*B + XF*B**2/THREE) )
      RETURN
      END
      SUBROUTINE KIRKFF (SIG0,RHO,UNPZ,RKN,RK0SQ,DELKNI)
C
C  SUBROUTINE TO CALCULATE NORMAL MODE ATTENUATION DUE TO
C   SURFACE SCATTERING
C  USES THE KIRCHOFF APPROXIMATION A LA INGENITO-MILLER
C
C  AUTHOR : DALE D ELLIS
C  DATE WRITTEN : JULY 10, 1979
C  LAST MODIFICATION : JULY 11, 1979
C  LAST EDIT : 27 APRIL, 1980
C
C INPUT PARAMETERS:
C  SIG0 - R.M.S. WAVE HEIGHT OF SURFACE
C  RHO  - DENSITY AT SURFACE
C  UNPZ - DERIVATIVE OF MODE FUNCTION AT THE SURFACE
C  RKN  - MODE WAVE NUMBER
C  RK0SQ -  WAVE NUMBER (SQUARED) OF SOUND SPEED AT THE SURFACE
C
C OUTPUT PARAMETERS:
C  DELKNI - ATTENUATION COEFFICIENT (IMAGINARY PART OF KN)
C
C
      REAL DELKNI,GAM0SQ,PW0,RHO,RK0SQ,RKN,SIG0,SK0,UNPZ
      DELKNI=0.
      GAM0SQ=RK0SQ-RKN**2
C          NO ATTENUATION IF THE EQUIVALENT RAY DOES NOT INTERACT
C            WITH THE SURFACE
      IF (GAM0SQ.LE.0.) RETURN
C
C          CALCULATE PLANE WAVE REFLECTION COEFFICIENT
      PW0=2.*SIG0**2 * GAM0SQ
C
C          CALCULATE SKIP DISTANCE OF THE EQUIVALENT RAY
      SK0= UNPZ**2 / (4.*RHO*RKN* SQRT(GAM0SQ) )
C
C          PRODUCT GIVES THE IMAGINARY PART OF THE WAVE NUMBER
      DELKNI=PW0*SK0
      RETURN
      END
      SUBROUTINE KIRKFB (SIG1,RHO,UNZH,UNPZH,RKN,RK1SQ,DELKNB)
C
C  CALCULATES NORMAL MODE ATTENUATION DUE TO BOTTOM ROUGHNESS
C   USES THE KIRCHOFF APPROXIMATION A LA JENSEN-FERLA (SNAP-SM121)
C   (SUBROUTINE IS BASED ON KIRKFF (10/07/79) SURF SCATT
C
C  AUTHOR : DALE D ELLIS
C  DATE WRITTEN : APRIL 27,1980
C  LAST MODIFICATION : APRIL 28,1980
C
C INPUT PARAMETERS:
C  SIG1 - R.M.S. ROUGHNESS OF BOTTOM
C  RHO  - DENSITY IN WATER COLUMN
C  UNZH - MODE FUNCTION AT THE BOTTOM
C  UNPZH - DERIVATIVE OF MODE FUNCTION AT THE BOTTOM
C  RKN  - MODE WAVE NUMBER
C  RK1SQ -  WAVE NUMBER (SQUARED) OF SOUND SPEED AT THE BOTTOM
C
C OUTPUT PARAMETERS:
C  DELKNB - ATTENUATION COEFFICIENT (IMAGINARY PART OF KN)
C
C
      REAL BRAK,DELKNB,GAM1SQ,RHO,RK1SQ,RKN,SIG1,UNPZH,UNZH
      DELKNB=0.
      GAM1SQ=RK1SQ-RKN**2
C          NO ATTENUATION IF THE EQUIVALENT RAY DOES NOT INTERACT
C            WITH THE BOTTOM
      IF (GAM1SQ.LE.0.) RETURN
C
C          CALCULATE ATTENUATION COEFFICIENT FOR BOTTOM ROUGHNESS
C         (FRMLA (22) P.15 OF SACLANTCEN MEMO. SM-121  JAN 1979)
C
      BRAK=UNPZH**2 + (UNZH**2*GAM1SQ)
      DELKNB=SIG1**2*SQRT(GAM1SQ)/(2.*RKN*RHO) * BRAK
      RETURN
      END

      BLOCK DATA BDMDS
      INTEGER LUO,NMIN,ITMAX,IEF
      REAL VMIN,VMAX,TOLK,TOLU,TOLGAM
      LOGICAL EIGF,EIGV,TLFLG,ATTFLG,GVLFLG,CPFLG,PFFLG
 
      COMMON /PAR/     VMIN,VMAX,NMIN,ITMAX,IEF
      COMMON /TOL/    TOLK,TOLU,TOLGAM
      COMMON /PRTFLG/ LUO,EIGF,EIGV,TLFLG,ATTFLG,GVLFLG,CPFLG,PFFLG
 
      DATA VMIN/0.1/, VMAX/1E10/, NMIN/1/, ITMAX/30/, IEF/6/,
     1    TOLK/1E-8/, TOLU/1E-4/, TOLGAM/1E-4/, LUO/0/,
     2    EIGF,EIGV,TLFLG,ATTFLG,GVLFLG,CPFLG,PFFLG/7*.FALSE./
      END

























